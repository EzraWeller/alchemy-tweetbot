"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const bignumber_js_1 = require("bignumber.js");
const contractWrapperFactory_1 = require("../contractWrapperFactory");
const iContractWrapperBase_1 = require("../iContractWrapperBase");
const loggingService_1 = require("../loggingService");
const transactionService_1 = require("../transactionService");
const web3EventService_1 = require("../web3EventService");
const standardToken_1 = require("./standardToken");
class MintableTokenWrapper extends standardToken_1.StandardTokenWrapper {
    constructor() {
        super(...arguments);
        this.name = "MintableToken";
        this.friendlyName = "Mintable Token";
        this.factory = exports.MintableTokenFactory;
    }
    /**
     * Mint tokens to recipient
     * @param options
     */
    mint(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!options.recipient) {
                throw new Error("recipient is not defined");
            }
            const amount = new bignumber_js_1.BigNumber(options.amount);
            if (amount.eq(0)) {
                loggingService_1.LoggingService.warn("MintableToken.mint: amount is zero.  Doing nothing.");
                return new iContractWrapperBase_1.ArcTransactionResult(null, this.contract);
            }
            this.logContractFunctionCall("MintableToken.mint", options);
            return this.wrapTransactionInvocation("MintableToken.mint", options, this.contract.mint, [options.recipient, options.amount]);
        });
    }
    /**
     * Terminate the ability to mint tokens
     * @param options
     */
    finishMinting(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logContractFunctionCall("MintableToken.finishMinting", options);
            return this.wrapTransactionInvocation("MintableToken.finishMinting", options, this.contract.finishMinting, []);
        });
    }
    approve(options) {
        const _super = name => super[name];
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const functionName = "MintableToken.approve";
            const payload = transactionService_1.TransactionService.publishKickoffEvent(functionName, options, 1);
            const eventContext = transactionService_1.TransactionService.newTxEventContext(functionName, payload, options);
            return _super("approve").call(this, Object.assign(options, { txEventContext: eventContext }));
        });
    }
    transfer(options) {
        const _super = name => super[name];
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const functionName = "MintableToken.transfer";
            const payload = transactionService_1.TransactionService.publishKickoffEvent(functionName, options, 1);
            const eventContext = transactionService_1.TransactionService.newTxEventContext(functionName, payload, options);
            return _super("transfer").call(this, Object.assign(options, { txEventContext: eventContext }));
        });
    }
    transferFrom(options) {
        const _super = name => super[name];
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const functionName = "MintableToken.transferFrom";
            const payload = transactionService_1.TransactionService.publishKickoffEvent(functionName, options, 1);
            const eventContext = transactionService_1.TransactionService.newTxEventContext(functionName, payload, options);
            return _super("transferFrom").call(this, Object.assign(options, { txEventContext: eventContext }));
        });
    }
    increaseApproval(options) {
        const _super = name => super[name];
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const functionName = "MintableToken.increaseApproval";
            const payload = transactionService_1.TransactionService.publishKickoffEvent(functionName, options, 1);
            const eventContext = transactionService_1.TransactionService.newTxEventContext(functionName, payload, options);
            return _super("increaseApproval").call(this, Object.assign(options, { txEventContext: eventContext }));
        });
    }
    decreaseApproval(options) {
        const _super = name => super[name];
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const functionName = "MintableToken.decreaseApproval";
            const payload = transactionService_1.TransactionService.publishKickoffEvent(functionName, options, 1);
            const eventContext = transactionService_1.TransactionService.newTxEventContext(functionName, payload, options);
            return _super("decreaseApproval").call(this, Object.assign(options, { txEventContext: eventContext }));
        });
    }
    hydrated() {
        super.hydrated();
        /* tslint:disable:max-line-length */
        this.Mint = this.createEventFetcherFactory(this.contract.Mint);
        this.MintFinished = this.createEventFetcherFactory(this.contract.MintFinished);
        /* tslint:enable:max-line-length */
    }
}
exports.MintableTokenWrapper = MintableTokenWrapper;
/**
 * defined just to add good type checking
 */
class MintableTokenFactoryType extends contractWrapperFactory_1.ContractWrapperFactory {
    deployed() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            throw new Error("MintableToken has not been deployed");
        });
    }
}
exports.MintableTokenFactoryType = MintableTokenFactoryType;
exports.MintableTokenFactory = new MintableTokenFactoryType("MintableToken", MintableTokenWrapper, new web3EventService_1.Web3EventService());
//# sourceMappingURL=mintableToken.js.map