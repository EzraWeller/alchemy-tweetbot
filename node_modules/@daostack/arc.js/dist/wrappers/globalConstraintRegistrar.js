"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const commonTypes_1 = require("../commonTypes");
const contractWrapperFactory_1 = require("../contractWrapperFactory");
const iContractWrapperBase_1 = require("../iContractWrapperBase");
const proposalGeneratorBase_1 = require("../proposalGeneratorBase");
const web3EventService_1 = require("../web3EventService");
class GlobalConstraintRegistrarWrapper extends proposalGeneratorBase_1.ProposalGeneratorBase {
    constructor() {
        super(...arguments);
        this.name = "GlobalConstraintRegistrar";
        this.friendlyName = "Global Constraint Registrar";
        this.factory = exports.GlobalConstraintRegistrarFactory;
    }
    /**
     * Submit a proposal to add or modify a given global constraint.
     * @param options
     */
    proposeToAddModifyGlobalConstraint(options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!options.avatar) {
                throw new Error("address is not defined");
            }
            if (!options.globalConstraint) {
                throw new Error("globalConstraint is not defined");
            }
            if (!options.globalConstraintParametersHash) {
                throw new Error("globalConstraintParametersHash is not defined");
            }
            if (!options.votingMachineHash) {
                throw new Error("votingMachineHash is not defined");
            }
            this.logContractFunctionCall("GlobalConstraintRegistrar.proposeGlobalConstraint", options);
            const txResult = yield this.wrapTransactionInvocation("GlobalConstraintRegistrar.proposeToAddModifyGlobalConstraint", options, this.contract.proposeGlobalConstraint, [options.avatar,
                options.globalConstraint,
                options.globalConstraintParametersHash,
                options.votingMachineHash]);
            return new iContractWrapperBase_1.ArcTransactionProposalResult(txResult.tx, this.contract, yield this.getVotingMachine(options.avatar));
        });
    }
    /**
     * Submit a proposal to remove a global constraint.
     * @param options
     */
    proposeToRemoveGlobalConstraint(options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!options.avatar) {
                throw new Error("avatar address is not defined");
            }
            if (!options.globalConstraintAddress) {
                throw new Error("avatar globalConstraint is not defined");
            }
            this.logContractFunctionCall("GlobalConstraintRegistrar.proposeToRemoveGC", options);
            const txResult = yield this.wrapTransactionInvocation("GlobalConstraintRegistrar.proposeToRemoveGlobalConstraint", options, this.contract.proposeToRemoveGC, [options.avatar,
                options.globalConstraintAddress]);
            return new iContractWrapperBase_1.ArcTransactionProposalResult(txResult.tx, this.contract, yield this.getVotingMachine(options.avatar));
        });
    }
    /**
     * EntityFetcherFactory for votable GlobalConstraintProposal.
     * @param avatarAddress
     */
    getVotableAddGcProposals(avatarAddress) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.proposalService.getProposalEvents({
                baseArgFilter: { _avatar: avatarAddress },
                proposalsEventFetcher: this.NewGlobalConstraintsProposal,
                transformEventCallback: (event) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    return this.getVotableProposal(event.args._avatar, event.args._proposalId);
                }),
                votableOnly: true,
                votingMachine: yield this.getVotingMachine(avatarAddress),
            });
        });
    }
    /**
     * EntityFetcherFactory for votable GlobalConstraintProposal.
     * @param avatarAddress
     */
    getVotableRemoveGcProposals(avatarAddress) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.proposalService.getProposalEvents({
                baseArgFilter: { _avatar: avatarAddress },
                proposalsEventFetcher: this.RemoveGlobalConstraintsProposal,
                transformEventCallback: (event) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    return this.getVotableProposal(event.args._avatar, event.args._proposalId);
                }),
                votableOnly: true,
                votingMachine: yield this.getVotingMachine(avatarAddress),
            });
        });
    }
    /**
     * EntityFetcherFactory for executed proposals.
     * @param avatarAddress
     */
    getExecutedProposals(avatarAddress) {
        return this.proposalService.getProposalEvents({
            baseArgFilter: { _avatar: avatarAddress },
            proposalsEventFetcher: this.ProposalExecuted,
            transformEventCallback: (event) => {
                return Promise.resolve({
                    avatarAddress: event.args._avatar,
                    proposalId: event.args._proposalId,
                    winningVote: event.args._param,
                });
            },
        });
    }
    getVotableProposal(avatarAddress, proposalId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const proposalParams = yield this.contract.organizationsProposals(avatarAddress, proposalId);
            return this.convertProposalPropsArrayToObject(proposalParams, proposalId);
        });
    }
    getParametersHash(params) {
        return this._getParametersHash(params.voteParametersHash, params.votingMachineAddress);
    }
    setParameters(params) {
        this.validateStandardSchemeParams(params);
        return super._setParameters("GlobalConstraintRegistrar.setParameters", params.txEventContext, params.voteParametersHash, params.votingMachineAddress);
    }
    getDefaultPermissions() {
        return commonTypes_1.DefaultSchemePermissions.GlobalConstraintRegistrar;
    }
    getSchemePermissions(avatarAddress) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this._getSchemePermissions(avatarAddress);
        });
    }
    getSchemeParameters(avatarAddress) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this._getSchemeParameters(avatarAddress);
        });
    }
    getParameters(paramsHash) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const params = yield this.getParametersArray(paramsHash);
            return {
                voteParametersHash: params[0],
                votingMachineAddress: params[1],
            };
        });
    }
    hydrated() {
        /* tslint:disable:max-line-length */
        this.NewGlobalConstraintsProposal = this.createEventFetcherFactory(this.contract.NewGlobalConstraintsProposal);
        this.RemoveGlobalConstraintsProposal = this.createEventFetcherFactory(this.contract.RemoveGlobalConstraintsProposal);
        this.ProposalExecuted = this.createEventFetcherFactory(this.contract.ProposalExecuted);
        this.ProposalDeleted = this.createEventFetcherFactory(this.contract.ProposalDeleted);
        /* tslint:enable:max-line-length */
    }
    convertProposalPropsArrayToObject(propsArray, proposalId) {
        return {
            constraintAddress: propsArray[0],
            paramsHash: propsArray[1],
            proposalId,
            proposalType: propsArray[2].toNumber(),
            voteToRemoveParamsHash: propsArray[3],
        };
    }
}
exports.GlobalConstraintRegistrarWrapper = GlobalConstraintRegistrarWrapper;
exports.GlobalConstraintRegistrarFactory = new contractWrapperFactory_1.ContractWrapperFactory("GlobalConstraintRegistrar", GlobalConstraintRegistrarWrapper, new web3EventService_1.Web3EventService());
var GlobalConstraintProposalType;
(function (GlobalConstraintProposalType) {
    GlobalConstraintProposalType[GlobalConstraintProposalType["Add"] = 1] = "Add";
    GlobalConstraintProposalType[GlobalConstraintProposalType["Remove"] = 2] = "Remove";
})(GlobalConstraintProposalType = exports.GlobalConstraintProposalType || (exports.GlobalConstraintProposalType = {}));
//# sourceMappingURL=globalConstraintRegistrar.js.map