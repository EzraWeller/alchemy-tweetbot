import { BigNumber } from "bignumber.js";
import { Address, BinaryVoteResult, Hash, SchemePermissions } from "../commonTypes";
import { ContractWrapperFactory } from "../contractWrapperFactory";
import { ArcTransactionDataResult, ArcTransactionProposalResult, ArcTransactionResult, IContractWrapperFactory, IUniversalSchemeWrapper, IVotingMachineWrapper } from "../iContractWrapperBase";
import { TxGeneratingFunctionOptions } from "../transactionService";
import { EntityFetcherFactory, EventFetcherFactory } from "../web3EventService";
import { RedeemEventResult } from "./commonEventInterfaces";
import { ExecuteProposalEventResult, NewProposalEventResult, OwnerVoteOptions, ProposalIdOption, ProposeOptions, VoteOptions, VoteWithSpecifiedAmountsOptions } from "./iIntVoteInterface";
import { IntVoteInterfaceWrapper } from "./intVoteInterface";
import { StandardTokenWrapper } from "./standardToken";
export declare class GenesisProtocolWrapper extends IntVoteInterfaceWrapper implements IUniversalSchemeWrapper, IVotingMachineWrapper {
    name: string;
    friendlyName: string;
    factory: IContractWrapperFactory<GenesisProtocolWrapper>;
    /**
     * Events
     */
    GPExecuteProposal: EventFetcherFactory<GPExecuteProposalEventResult>;
    Stake: EventFetcherFactory<StakeEventResult>;
    Redeem: EventFetcherFactory<RedeemEventResult>;
    RedeemReputation: EventFetcherFactory<RedeemEventResult>;
    RedeemDaoBounty: EventFetcherFactory<RedeemEventResult>;
    /**
     * Stake some tokens on the final outcome matching this vote.
     *
     * A transfer of tokens from the staker to this GenesisProtocol scheme
     * is automatically approved and executed on the token with which
     * this GenesisProtocol scheme was deployed.
     *
     * @param {StakeConfig} options
     * @returns Promise<ArcTransactionResult>
     */
    stake(options?: StakeConfig): Promise<ArcTransactionResult>;
    /**
     * Preapprove the transfer of stakingTokens from the default account to this GenesisProtocol contract,
     * and then stake, all in a single transaction.
     * @param options
     */
    stakeWithApproval(options?: StakeConfig): Promise<ArcTransactionResult>;
    /**
     * Redeem any tokens and reputation, excluding bounty, that are due the beneficiary from the outcome of the proposal.
     * @param {RedeemConfig} options
     * @returns Promise<ArcTransactionResult>
     */
    redeem(options?: RedeemConfig): Promise<ArcTransactionResult>;
    /**
     * Redeem any token bounty that are due the beneficiary from the outcome of the proposal.
     * @param {RedeemConfig} options
     * @returns Promise<ArcTransactionResult>
     */
    redeemDaoBounty(options?: RedeemConfig): Promise<ArcTransactionResult>;
    /**
     * Return whether a proposal should be shifted to the boosted phase.
     * @param {ShouldBoostConfig} options
     * @returns Promise<boolean>
     */
    shouldBoost(options?: ShouldBoostConfig): Promise<boolean>;
    /**
     * Return the current proposal score.
     * @param {GetScoreConfig} options
     * @returns Promise<BigNumber>
     */
    getScore(options?: GetScoreConfig): Promise<BigNumber>;
    /**
     * Return the threshold that is required by a proposal to it shift it into boosted state.
     * The computation depends on the current number of boosted proposals in the DAO
     * as well as the GenesisProtocol parameters thresholdConstA and thresholdConstB.
     * @param {GetThresholdConfig} options
     */
    getThreshold(options?: GetThresholdConfig): Promise<BigNumber>;
    /**
     * Returns a promise of the number of boosted proposals, not including those
     * that have expired but have not yet been executed to update their status.
     */
    getBoostedProposalsCount(avatar: Address): Promise<BigNumber>;
    /**
     * Return the current balances on this GenesisProtocol's staking and the given avatar's native tokens.
     * This can be useful, for example, if you want to know in advance whether the avatar has enough funds
     * at the moment to payout rewards to stakers and voters.
     * It also returns the respective tokens' truffle contracts.
     * @param options
     */
    getTokenBalances(options?: GetTokenBalancesOptions): Promise<GenesisProtocolDaoTokenBalances>;
    /**
     * Return the number of possible choices when voting for the proposal.
     * @param {GetNumberOfChoicesConfig} options
     * @returns Promise<number>
     */
    getNumberOfChoices(options?: GetNumberOfChoicesConfig): Promise<number>;
    /**
     * Return the vote and the amount of reputation of the voter committed to this proposal
     * @param {GetVoterInfoResult} options
     * @returns Promise<GetVoterInfoResult>
     */
    getVoterInfo(options?: GetVoterInfoConfig): Promise<GetVoterInfoResult>;
    /**
     * Returns the reputation currently voted on the given choice.
     * @param {GetVoteStatusConfig} options
     * @returns Promise<BigNumber>
     */
    getVoteStatus(options?: GetVoteStatusConfig): Promise<BigNumber>;
    /**
     * Return the preBoosted votes, amount staked per vote, total staked and
     * total staked net voters' take for a given proposal
     * @param {GetProposalStatusConfig} options
     * @returns Promise<GetProposalStatusResult>
     */
    getProposalStatus(options?: GetProposalStatusConfig): Promise<GetProposalStatusResult>;
    /**
     * Return the DAO avatar address under which the proposal was made
     * @param {GetProposalAvatarConfig} options
     * @returns Promise<string>
     */
    getProposalAvatar(options?: GetProposalAvatarConfig): Promise<string>;
    /**
     * Return the score threshold params for the given DAO.
     * @param {GetScoreThresholdParamsConfig} options
     * @returns Promise<GetScoreThresholdParamsResult>
     */
    getScoreThresholdParams(options?: GetScoreThresholdParamsConfig): Promise<GetScoreThresholdParamsResult>;
    /**
     * Return the vote and stake amount for a given proposal and staker.
     * @param {GetStakerInfoConfig} options
     * @returns Promise<GetStakerInfoResult>
     */
    getStakerInfo(options?: GetStakerInfoConfig): Promise<GetStakerInfoResult>;
    /**
     * Return the winningVote for a given proposal.
     * @param {GetWinningVoteConfig} options
     * @returns Promise<number>
     */
    getWinningVote(options?: GetWinningVoteConfig): Promise<number>;
    /**
     * Return the current state of a given proposal.
     * @param {GetStateConfig} options
     * @returns Promise<number>
     */
    getState(options?: GetStateConfig): Promise<ProposalState>;
    /**
     * EntityFetcherFactory for votable GenesisProtocolProposal.
     * @param avatarAddress
     */
    readonly VotableGenesisProtocolProposals: EntityFetcherFactory<GenesisProtocolProposal, NewProposalEventResult>;
    /**
     * Cancel the given proposal
     * @param options
     */
    cancelProposal(options: ProposalIdOption): Promise<ArcTransactionResult>;
    ownerVote(options: OwnerVoteOptions): Promise<ArcTransactionResult>;
    cancelVote(options: ProposalIdOption): Promise<ArcTransactionResult>;
    /**
     * EntityFetcherFactory for executed ExecutedGenesisProposal.
     * The Arc GenesisProtocol contract retains the original proposal struct after execution.
     * @param avatarAddress
     */
    readonly ExecutedProposals: EntityFetcherFactory<ExecutedGenesisProposal, ExecuteProposalEventResult>;
    /**
     * Returns a promise of the execution state of the given proposal.  The result is
     * ExecutionState.None if the proposal has not been executed or is not found.
     * @param proposalId
     */
    getProposalExecutionState(proposalId: Hash): Promise<ExecutionState>;
    /**
     * Returns promise of a `GenesisProtocolProposal` for the given proposal id.
     * @param avatarAddress
     * @param proposalId
     */
    getProposal(proposalId: Hash): Promise<GenesisProtocolProposal>;
    getParametersHash(params: GenesisProtocolParams): Promise<Hash>;
    /**
     * Set the contract parameters.
     * @param {GenesisProtocolParams} params
     * @returns parameters hash
     */
    setParameters(params: GenesisProtocolParams & TxGeneratingFunctionOptions): Promise<ArcTransactionDataResult<Hash>>;
    getDefaultPermissions(): SchemePermissions;
    getSchemePermissions(avatarAddress: Address): Promise<SchemePermissions>;
    getSchemeParameters(avatarAddress: Address): Promise<GenesisProtocolParams>;
    getParameters(paramsHash: Hash): Promise<GetGenesisProtocolParamsResult>;
    /**
     * Returns promise of the staking token as StandardTokenWrapper.
     * @returns Promise<StandardTokenWrapper>
     */
    getStakingToken(): Promise<StandardTokenWrapper>;
    /**
     * Returns promise of the staking token address.
     * @returns Promise<Address>
     */
    getStakingTokenAddress(): Promise<Address>;
    propose(options: ProposeOptions & TxGeneratingFunctionOptions): Promise<ArcTransactionProposalResult>;
    vote(options: VoteOptions & TxGeneratingFunctionOptions): Promise<ArcTransactionResult>;
    voteWithSpecifiedAmounts(options: VoteWithSpecifiedAmountsOptions & TxGeneratingFunctionOptions): Promise<ArcTransactionResult>;
    execute(options: ProposalIdOption & TxGeneratingFunctionOptions): Promise<ArcTransactionResult>;
    protected hydrated(): void;
    private convertProposalPropsArrayToObject(proposalArray, proposalId);
}
/**
 * defined just to add good type checking
 */
export declare class GenesisProtocolFactoryType extends ContractWrapperFactory<GenesisProtocolWrapper> {
    /**
     * Migrate a new instance of GenesisProtocol.
     * @param stakingTokenAddress The token that will be used when staking.  Typically
     * is the token of the DAO that is going to use this GenesisProtocol.
     */
    new(stakingTokenAddress: Address): Promise<GenesisProtocolWrapper>;
}
export declare const GenesisProtocolFactory: GenesisProtocolFactoryType;
export interface StakeEventResult {
    _amount: BigNumber;
    /**
     * indexed
     */
    _avatar: Address;
    /**
     * indexed
     */
    _proposalId: Hash;
    _vote: number;
    /**
     * indexed
     */
    _staker: Address;
}
export interface GenesisProtocolParams {
    /**
     * The time limit in seconds for a proposal to be in the boosted phase,
     * inclusive of the quietEndingPeriod, in seconds.
     * Default is 259200 (three days).
     */
    boostedVotePeriodLimit: number;
    /**
     * Multiple of a winning stake to be rewarded as bounty.
     * Must be greater than stakerFeeRatioForVoters and less than 2*stakerFeeRatioForVoters.
     * Default is 75.
     */
    daoBountyConst: number;
    /**
     * Upper bound on the total bounty amount on a proposal.
     * Default is 100, converted to Wei.
     */
    daoBountyLimit: BigNumber | string;
    /**
     * A floor on the staking fee which is normally computed using
     * [[GenesisProtocolParams.stakerFeeRatioForVoters]], in Wei.
     * Default is 0.
     */
    minimumStakingFee: BigNumber | string;
    /**
     * The time limit in seconds that a proposal can be in the preBoosted phase before
     * it will be automatically closed, in seconds, with a winning vote of NO, regardless
     * of the actual value of the winning vote at the time expiration.
     * Note an attempt must be made to execute before the proposal state will actually change.
     * Default is 1814400 (three weeks).
     */
    preBoostedVotePeriodLimit: number;
    /**
     * The percent of the DAO's total supply of reputation that, when exceeded
     * by the amount of reputation behind a vote (yes or no), will result
     * in the immediate execution of the proposal, during either the preboosted
     * or boosted phases.
     * Must be greater than zero and less than or equal to 100.
     * Default is 50.
     */
    preBoostedVoteRequiredPercentage: number;
    /**
     * Constant A in the calculation of the proposer's reputation reward.
     * Must be between 0 and 100000000.
     * Default is 5.
     */
    proposingRepRewardConstA: number;
    /**
     * Constant B in the calculation of the proposer's reputation reward.
     * Must be between 0 and 100000000.
     * Default is 5.
     */
    proposingRepRewardConstB: number;
    /**
     * The duration, in seconds, at the end of the boosted phase during which any vote that changes the
     * outcome of a proposal will cause the boosted phase to be extended by the amount
     * of the quietEndingPeriod.  If the quietEndingPeriod expires then the proposal
     * expires and may be executed.  It is a moving window:  If the winning vote switches during
     * the quietEndingPeriod then it restarts at the point in time when the vote switched, thus extending
     * the boosted period.
     * Default is 86400 (one day).
     */
    quietEndingPeriod: number;
    /**
     * For executed proposals, the percentage of staked tokens that is rewarded to all voters,
     * regardless of the vote outcome, the staked vote outcome, or how the voter voted.
     * Voters share this amount in proportion to the amount of reputation they voted.
     * Must be between 0 and 100.
     * Default is 50.
     */
    stakerFeeRatioForVoters: number;
    /**
     * Constant A in the threshold calculation, in Wei. See [[GenesisProtocolWrapper.getThreshold]].
     * If the difference between Yes and No votes exceeds the threshold, then the
     * proposal may be boosted.
     * Must be between 0 and 100000000 (converted to Wei).
     * Default is 7, converted to Wei.
     */
    thresholdConstA: BigNumber | string;
    /**
     * Constant B in the threshold calculation. See [[GenesisProtocolWrapper.getThreshold]].
     * If the difference between Yes and No votes exceeds the threshold, then the
     * proposal may be boosted.
     * Must be greater than zero and less than or equal to 100000000.
     * Default is 3.
     */
    thresholdConstB: number;
    /**
     * The percentage of losing pre-boosted voters' lost reputation (see votersReputationLossRatio)
     * rewarded to winning pre-boosted voters.
     * Must be between 0 and 100.
     * Default is 80.
     */
    votersGainRepRatioFromLostRep: number;
    /**
     * The percentage of reputation deducted from losing pre-boosted voters.
     * Must be between 0 and 100.
     * Default is 1.
     */
    votersReputationLossRatio: number;
}
export interface GetGenesisProtocolParamsResult {
    boostedVotePeriodLimit: number;
    daoBountyConst: number;
    daoBountyLimit: BigNumber;
    minimumStakingFee: BigNumber;
    preBoostedVotePeriodLimit: number;
    preBoostedVoteRequiredPercentage: number;
    proposingRepRewardConstA: number;
    proposingRepRewardConstB: number;
    quietEndingPeriod: number;
    stakerFeeRatioForVoters: number;
    thresholdConstA: BigNumber | string;
    thresholdConstB: number;
    votersGainRepRatioFromLostRep: number;
    votersReputationLossRatio: number;
}
export interface GetVoterInfoResult {
    vote: number;
    reputation: BigNumber;
}
export interface GetProposalStatusResult {
    /**
     * Number of preboosted votes against
     */
    preBoostedVotesNo: BigNumber;
    /**
     * Number of preboosted votes for
     */
    preBoostedVotesYes: BigNumber;
    /**
     * Number of staking tokens staked against
     */
    stakesNo: BigNumber;
    /**
     * Number of staking tokens staked for
     */
    stakesYes: BigNumber;
    /**
     * Number of staking tokens currently redeemable by stakers
     */
    totalStakerStakes: BigNumber;
    /**
     * Total number of staking tokens currently redeemable by everyone
     */
    totalStaked: BigNumber;
}
export interface GetScoreThresholdParamsResult {
    thresholdConstA: BigNumber;
    thresholdConstB: number;
}
export interface GetStakerInfoResult {
    vote: number;
    stake: BigNumber;
}
export interface StakeConfig {
    /**
     * token amount to stake on the outcome resulting in this vote, in Wei
     */
    amount: BigNumber | string;
    /**
     * unique hash of proposal index
     */
    proposalId: string;
    /**
     * the choice of vote. Can be 1 (YES) or 2 (NO).
     */
    vote: number;
}
export interface RedeemConfig {
    /**
     * unique hash of proposal index
     */
    proposalId: string;
    /**
     * agent to whom to award the proposal payoffs
     */
    beneficiaryAddress: Address;
}
export interface ShouldBoostConfig {
    /**
     * unique hash of proposal index
     */
    proposalId: string;
}
export interface GetScoreConfig {
    /**
     * unique hash of proposal index
     */
    proposalId: string;
}
export interface GetThresholdConfig {
    /**
     * the DAO's avatar address
     */
    avatar: Address;
}
export interface GetVoterInfoConfig {
    /**
     * unique hash of proposal index
     */
    proposalId: string;
    voter: string;
}
export interface GetProposalStatusConfig {
    /**
     * unique hash of proposal index
     */
    proposalId: string;
}
export interface GetTotalReputationSupplyConfig {
    /**
     * unique hash of proposal index
     */
    proposalId: string;
}
export interface GetProposalAvatarConfig {
    /**
     * unique hash of proposal index
     */
    proposalId: string;
}
export interface GetScoreThresholdParamsConfig {
    /**
     * the DAO's avatar address
     */
    avatar: Address;
}
export interface GetStakerInfoConfig {
    /**
     * unique hash of proposal index
     */
    proposalId: string;
    /**
     * address of the staking agent
     */
    staker: string;
}
export interface GetWinningVoteConfig {
    /**
     * unique hash of proposal index
     */
    proposalId: string;
}
export interface GetStateConfig {
    /**
     * unique hash of proposal index
     */
    proposalId: string;
}
export declare enum ExecutionState {
    None = 0,
    PreBoostedTimeOut = 1,
    PreBoostedBarCrossed = 2,
    BoostedTimeOut = 3,
    BoostedBarCrossed = 4,
}
export interface GPExecuteProposalEventResult {
    /**
     * indexed
     */
    _proposalId: Hash;
    /**
     * _executionState.toNumber() will give you a value from the enum `ExecutionState`
     */
    _executionState: BigNumber;
}
export declare enum ProposalState {
    None = 0,
    Closed = 1,
    Executed = 2,
    PreBoosted = 3,
    Boosted = 4,
    QuietEndingPeriod = 5,
}
export interface GetTokenBalancesOptions {
    avatarAddress: Address;
}
export interface GenesisProtocolDaoTokenBalances {
    /**
     * The native token's truffle contract
     */
    nativeToken: any;
    /**
     * The avatar's balance off native tokens, in Wei
     */
    nativeTokenBalance: BigNumber;
    /**
     * The standard token's truffle contract
     */
    stakingToken: any;
    /**
     * The avatar's balance of staking tokens, in Wei
     */
    stakingTokenBalance: BigNumber;
}
export declare const GetDefaultGenesisProtocolParameters: () => Promise<GenesisProtocolParams>;
export interface ExecutedGenesisProposal extends GenesisProtocolProposal {
    decision: BinaryVoteResult;
    /**
     * total reputation in the DAO at the time the proposal is created in the voting machine
     */
    totalReputation: BigNumber;
    executionState: ExecutionState;
}
export interface GenesisProtocolProposal {
    avatarAddress: Address;
    /**
     * in seconds
     */
    boostedPhaseTime: number;
    /**
     * in seconds
     */
    currentBoostedVotePeriodLimit: number;
    daoBountyRemain: BigNumber;
    executable: Address;
    lostReputation: BigNumber;
    numOfChoices: number;
    paramsHash: Hash;
    proposalId: Hash;
    proposer: Address;
    state: ProposalState;
    /**
     * in seconds
     */
    submittedTime: number;
    votersStakes: BigNumber;
    winningVote: number;
}
export interface GetVoteStatusConfig {
    /**
     * unique hash of proposal index
     */
    proposalId: string;
    /**
     * the choice of vote, like 1 (YES) or 2 (NO).
     */
    vote: number;
}
export interface GetTokenBalancesOptions {
    avatarAddress: Address;
}
export interface GetNumberOfChoicesConfig {
    /**
     * unique hash of proposal index
     */
    proposalId: string;
}
