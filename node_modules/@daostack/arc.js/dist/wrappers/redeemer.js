"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const contractWrapperBase_1 = require("../contractWrapperBase");
const contractWrapperFactory_1 = require("../contractWrapperFactory");
const web3EventService_1 = require("../web3EventService");
class RedeemerWrapper extends contractWrapperBase_1.ContractWrapperBase {
    constructor() {
        super(...arguments);
        this.name = "Redeemer";
        this.friendlyName = "Redeemer";
        this.factory = exports.RedeemerFactory;
    }
    /**
     * Redeems rewards for a ContributionReward proposal in a single transaction.
     * Calls execute on the proposal if it is not yet executed.
     * Redeems rewardable reputation and stake from the GenesisProtocol.
     * Redeem rewardable contribution proposal rewards.
     * @param options
     */
    redeem(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!options.avatarAddress) {
                throw new Error("avatarAddress is not defined");
            }
            if (!options.beneficiaryAddress) {
                throw new Error("beneficiaryAddress is not defined");
            }
            if (!options.proposalId) {
                throw new Error("proposalId is not defined");
            }
            this.logContractFunctionCall("Redeemer.redeem", options);
            return this.wrapTransactionInvocation("Redeemer.redeem", options, this.contract.redeem, [options.proposalId, options.avatarAddress, options.beneficiaryAddress]);
        });
    }
    /**
     * Returns the amounts that would be redeemed if `Redeemer.redeem` were invoked right now.
     * @param options
     */
    redeemables(options) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!options.avatarAddress) {
                throw new Error("avatarAddress is not defined");
            }
            if (!options.beneficiaryAddress) {
                throw new Error("beneficiaryAddress is not defined");
            }
            if (!options.proposalId) {
                throw new Error("proposalId is not defined");
            }
            this.logContractFunctionCall("Redeemer.redeem.call", options);
            const result = yield this.contract.redeem.call(options.proposalId, options.avatarAddress, options.beneficiaryAddress)
                // correct for fake truffle promises
                .then((r) => r)
                .catch((ex) => {
                throw new Error(ex.message);
            });
            return {
                contributionRewardEther: result[3][2],
                contributionRewardExternalToken: result[3][3],
                contributionRewardNativeToken: result[3][1],
                contributionRewardReputation: result[3][0],
                daoStakingBountyPotentialReward: result[1][1],
                daoStakingBountyReward: result[1][0],
                proposalExecuted: result[2],
                proposalId: options.proposalId,
                proposerReputationAmount: result[0][4],
                stakerReputationAmount: result[0][1],
                stakerTokenAmount: result[0][0],
                voterReputationAmount: result[0][3],
                voterTokenAmount: result[0][2],
            };
        });
    }
}
exports.RedeemerWrapper = RedeemerWrapper;
/**
 * defined just to add good type checking
 */
class RedeemerFactoryType extends contractWrapperFactory_1.ContractWrapperFactory {
    new(contributionRewardAddress, genesisProtocolAddress) {
        const _super = name => super[name];
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return _super("new").call(this, contributionRewardAddress, genesisProtocolAddress);
        });
    }
}
exports.RedeemerFactoryType = RedeemerFactoryType;
exports.RedeemerFactory = new RedeemerFactoryType("Redeemer", RedeemerWrapper, new web3EventService_1.Web3EventService());
//# sourceMappingURL=redeemer.js.map