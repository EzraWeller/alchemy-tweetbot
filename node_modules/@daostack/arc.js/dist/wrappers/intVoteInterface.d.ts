import { BigNumber } from "bignumber.js";
import { Address, Hash } from "../commonTypes";
import { ContractWrapperBase } from "../contractWrapperBase";
import { ContractWrapperFactory } from "../contractWrapperFactory";
import { ArcTransactionProposalResult, ArcTransactionResult, IContractWrapperFactory } from "../iContractWrapperBase";
import { TxGeneratingFunctionOptions } from "../transactionService";
import { EventFetcherFactory } from "../web3EventService";
import { CancelProposalEventResult, CancelVotingEventResult, ExecuteProposalEventResult, GetAllowedRangeOfChoicesResult, IIntVoteInterface, NewProposalEventResult, OwnerVoteOptions, ProposalIdOption, ProposeOptions, VoteOptions, VoteProposalEventResult, VoteStatusOptions, VoteWithSpecifiedAmountsOptions } from "./iIntVoteInterface";
/**
 * Provides the services of any voting machine that implements the `IntVoteInterface`
 * Arc contract interface.  Also serves as the base class for all the specific
 * voting machine contract wrapper classes.
 */
export declare class IntVoteInterfaceWrapper extends ContractWrapperBase implements IIntVoteInterface {
    factory: IContractWrapperFactory<any>;
    name: string;
    friendlyName: string;
    /**
     * Get or watch events fired on the creation of a new proposal.
     */
    NewProposal: EventFetcherFactory<NewProposalEventResult>;
    /**
     * Get or watch events fired when a vote is cancelled.
     * Note you won't get this from GenesisProtocol whose proposals and votes are not cancellable
     */
    CancelProposal: EventFetcherFactory<CancelProposalEventResult>;
    /**
     * Get or watch events fired when proposals have been executed
     */
    ExecuteProposal: EventFetcherFactory<ExecuteProposalEventResult>;
    /**
     * Get or watch events fired whenever votes are cast on a proposal
     */
    VoteProposal: EventFetcherFactory<VoteProposalEventResult>;
    /**
     * Get or watch events fired when a voter's vote is cancelled.
     * Note you won't get this from GenesisProtocol whose proposals and votes are not cancellable
     */
    CancelVoting: EventFetcherFactory<CancelVotingEventResult>;
    /**
     * Get or watch NewProposal events, filtering out proposals that are no longer votable.
     */
    readonly VotableProposals: EventFetcherFactory<NewProposalEventResult>;
    /**
     * Register a new proposal with the given parameters. Every proposal is given a unique ID
     * which is a hash generated by calculating the keccak256 of a packing of an
     * incremented counter and the address of the voting machine.
     * @param options
     */
    propose(options: ProposeOptions & TxGeneratingFunctionOptions): Promise<ArcTransactionProposalResult>;
    /**
     * Cancel the given proposal
     * @param options
     */
    cancelProposal(options: ProposalIdOption & TxGeneratingFunctionOptions): Promise<ArcTransactionResult>;
    /**
     * Vote on behalf of the owner of the proposal, ie the agent that created it.
     * @param options
     */
    ownerVote(options: OwnerVoteOptions & TxGeneratingFunctionOptions): Promise<ArcTransactionResult>;
    /**
     * Vote on behalf of the current account.
     * @param options
     */
    vote(options: VoteOptions & TxGeneratingFunctionOptions): Promise<ArcTransactionResult>;
    /**
     * Vote specified reputation amount
     * @param options
     */
    voteWithSpecifiedAmounts(options: VoteWithSpecifiedAmountsOptions & TxGeneratingFunctionOptions): Promise<ArcTransactionResult>;
    /**
     * Cancel voting on the proposal.
     * @param options
     */
    cancelVote(options: ProposalIdOption & TxGeneratingFunctionOptions): Promise<ArcTransactionResult>;
    /**
     * Get the number of voting choices allowed by the proposal.
     * @param options
     */
    getNumberOfChoices(options: ProposalIdOption): Promise<number>;
    /**
     * Get whether the proposal is in a state where it can be voted-upon.
     * @param proposalId
     */
    isVotable(options: ProposalIdOption): Promise<boolean>;
    /**
     * Get the number of votes currently cast on the given choice.
     * @param options
     */
    voteStatus(options: VoteStatusOptions): Promise<BigNumber>;
    /**
     * get whether voters are allowed to cast an abstaining vote on these proposals.
     */
    isAbstainAllow(): Promise<boolean>;
    /**
     * Attempt to execute the given proposal vote.
     * @param proposalId
     */
    execute(options: ProposalIdOption & TxGeneratingFunctionOptions): Promise<ArcTransactionResult>;
    /**
     * Return an array of the current counts of each vote choice on the proposal.
     * For straight Abstain, Yes and No votes you can use the values of the
     * `BinaryVoteResult` enum to dereference the array.  The Abstain vote
     * (in the zeroeth position) is always given even if the voting machine
     * does not allow abstentions.
     *
     * @param proposalId
     */
    getCurrentVoteStatus(proposalId: Address): Promise<Array<BigNumber>>;
    /**
     * Returns promise of the allowed range of choices for a voting machine.
     */
    getAllowedRangeOfChoices(): Promise<GetAllowedRangeOfChoicesResult>;
    protected hydrated(): void;
    protected _validateVote(vote: number, proposalId: Hash): Promise<void>;
}
export declare class IntVoteInterfaceFactoryType extends ContractWrapperFactory<IntVoteInterfaceWrapper> {
    new(): Promise<IntVoteInterfaceWrapper>;
    deployed(): Promise<IntVoteInterfaceWrapper>;
}
export declare const IntVoteInterfaceFactory: IntVoteInterfaceFactoryType;
