"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const contractWrapperFactory_1 = require("../contractWrapperFactory");
const proposalService_1 = require("../proposalService");
const transactionService_1 = require("../transactionService");
const web3EventService_1 = require("../web3EventService");
const intVoteInterface_1 = require("./intVoteInterface");
class AbsoluteVoteWrapper extends intVoteInterface_1.IntVoteInterfaceWrapper {
    constructor() {
        super(...arguments);
        this.name = "AbsoluteVote";
        this.friendlyName = "Absolute Vote";
        this.factory = exports.AbsoluteVoteFactory;
    }
    /**
     * EntityFetcherFactory for votable proposals.
     * @param avatarAddress
     */
    get VotableAbsoluteVoteProposals() {
        const proposalService = new proposalService_1.ProposalService(this.web3EventService);
        return proposalService.getProposalEvents({
            proposalsEventFetcher: this.NewProposal,
            transformEventCallback: (event) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                return {
                    avatarAddress: event.args._avatar,
                    numOfChoices: event.args._numOfChoices.toNumber(),
                    paramsHash: event.args._paramsHash,
                    proposalId: event.args._proposalId,
                    proposerAddress: event.args._proposer,
                };
            }),
            votableOnly: true,
            votingMachine: this,
        });
    }
    getParametersHash(params) {
        params = Object.assign({}, {
            ownerVote: true,
            votePerc: 50,
        }, params);
        return this._getParametersHash(params.reputation, params.votePerc, params.ownerVote);
    }
    setParameters(params) {
        params = Object.assign({}, {
            ownerVote: true,
            votePerc: 50,
        }, params);
        if (!params.reputation) {
            throw new Error("reputation must be set");
        }
        return super._setParameters("AbsoluteVote.setParameters", params.txEventContext, params.reputation, params.votePerc, params.ownerVote);
    }
    getParameters(paramsHash) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const params = yield this.getParametersArray(paramsHash);
            return {
                ownerVote: params[2],
                reputation: params[0],
                votePerc: params[1].toNumber(),
            };
        });
    }
    propose(options) {
        const _super = name => super[name];
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const functionName = "AbsoluteVote.propose";
            const payload = transactionService_1.TransactionService.publishKickoffEvent(functionName, options, 1);
            const eventContext = transactionService_1.TransactionService.newTxEventContext(functionName, payload, options);
            return _super("propose").call(this, Object.assign(options, { txEventContext: eventContext }));
        });
    }
    vote(options) {
        const _super = name => super[name];
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const functionName = "AbsoluteVote.vote";
            const payload = transactionService_1.TransactionService.publishKickoffEvent(functionName, options, 1);
            const eventContext = transactionService_1.TransactionService.newTxEventContext(functionName, payload, options);
            return _super("vote").call(this, Object.assign(options, { txEventContext: eventContext }));
        });
    }
    voteWithSpecifiedAmounts(options) {
        const _super = name => super[name];
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const functionName = "AbsoluteVote.voteWithSpecifiedAmounts";
            const payload = transactionService_1.TransactionService.publishKickoffEvent(functionName, options, 1);
            const eventContext = transactionService_1.TransactionService.newTxEventContext(functionName, payload, options);
            return _super("voteWithSpecifiedAmounts").call(this, Object.assign(options, { txEventContext: eventContext }));
        });
    }
    execute(options) {
        const _super = name => super[name];
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const functionName = "AbsoluteVote.execute";
            const payload = transactionService_1.TransactionService.publishKickoffEvent(functionName, options, 1);
            const eventContext = transactionService_1.TransactionService.newTxEventContext(functionName, payload, options);
            return _super("execute").call(this, Object.assign(options, { txEventContext: eventContext }));
        });
    }
    cancelProposal(options) {
        const _super = name => super[name];
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const functionName = "AbsoluteVote.execute";
            const payload = transactionService_1.TransactionService.publishKickoffEvent(functionName, options, 1);
            const eventContext = transactionService_1.TransactionService.newTxEventContext(functionName, payload, options);
            return _super("cancelProposal").call(this, Object.assign(options, { txEventContext: eventContext }));
        });
    }
    ownerVote(options) {
        const _super = name => super[name];
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const functionName = "AbsoluteVote.execute";
            const payload = transactionService_1.TransactionService.publishKickoffEvent(functionName, options, 1);
            const eventContext = transactionService_1.TransactionService.newTxEventContext(functionName, payload, options);
            return _super("ownerVote").call(this, Object.assign(options, { txEventContext: eventContext }));
        });
    }
    cancelVote(options) {
        const _super = name => super[name];
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const functionName = "AbsoluteVote.execute";
            const payload = transactionService_1.TransactionService.publishKickoffEvent(functionName, options, 1);
            const eventContext = transactionService_1.TransactionService.newTxEventContext(functionName, payload, options);
            return _super("cancelVote").call(this, Object.assign(options, { txEventContext: eventContext }));
        });
    }
    hydrated() {
        super.hydrated();
        /* tslint:disable:max-line-length */
        this.AVVoteProposal = this.createEventFetcherFactory(this.contract.AVVoteProposal);
        this.RefreshReputation = this.createEventFetcherFactory(this.contract.RefreshReputation);
        /* tslint:enable:max-line-length */
    }
}
exports.AbsoluteVoteWrapper = AbsoluteVoteWrapper;
exports.AbsoluteVoteFactory = new contractWrapperFactory_1.ContractWrapperFactory("AbsoluteVote", AbsoluteVoteWrapper, new web3EventService_1.Web3EventService());
//# sourceMappingURL=absoluteVote.js.map