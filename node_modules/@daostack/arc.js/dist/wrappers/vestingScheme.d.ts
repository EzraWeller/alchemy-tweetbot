import * as BigNumber from "bignumber.js";
import { Address, Hash, SchemePermissions } from "../commonTypes";
import { ContractWrapperFactory } from "../contractWrapperFactory";
import { ArcTransactionDataResult, ArcTransactionProposalResult, ArcTransactionResult, IContractWrapperFactory, IUniversalSchemeWrapper, StandardSchemeParams } from "../iContractWrapperBase";
import { ProposalGeneratorBase } from "../proposalGeneratorBase";
import { TxGeneratingFunctionOptions } from "../transactionService";
import { EntityFetcherFactory, EventFetcherFactory } from "../web3EventService";
import { SchemeProposalExecuted, SchemeProposalExecutedEventResult } from "./commonEventInterfaces";
export declare class VestingSchemeWrapper extends ProposalGeneratorBase implements IUniversalSchemeWrapper {
    name: string;
    friendlyName: string;
    factory: IContractWrapperFactory<VestingSchemeWrapper>;
    /**
     * Events
     */
    /**
     * fired when a proposal is executed whether an agreement is created or not.
     */
    ProposalExecuted: EventFetcherFactory<SchemeProposalExecutedEventResult>;
    /**
     * fired when proposal is executed and an agreement is created
     */
    ProposedVestedAgreement: EventFetcherFactory<ProposedVestedAgreementEventResult>;
    /**
     * fired when a proposal is submitted to create an agreement
     */
    AgreementProposal: EventFetcherFactory<AgreementProposalEventResult>;
    /**
     * fired when an agreement is created through `create` (not-through a proposal process)
     */
    NewVestedAgreement: EventFetcherFactory<NewVestedAgreementEventResult>;
    SignToCancelAgreement: EventFetcherFactory<SignToCancelAgreementEventResult>;
    RevokeSignToCancelAgreement: EventFetcherFactory<RevokeSignToCancelAgreementEventResult>;
    AgreementCancel: EventFetcherFactory<AgreementCancelEventResult>;
    Collect: EventFetcherFactory<CollectEventResult>;
    /**
     * see CreateVestingAgreementConfig
     */
    private defaultCreateOptions;
    /**
     * Submit a proposal to create a vesting agreement.
     * @param {ProposeVestingAgreementConfig} options
     */
    proposeVestingAgreement(options?: ProposeVestingAgreementConfig): Promise<ArcTransactionProposalResult>;
    /**
     * Create a new vesting agreement
     * @param {CreateVestingAgreementConfig} options
     */
    create(options?: CreateVestingAgreementConfig): Promise<ArcTransactionAgreementResult>;
    /**
     * Sign to cancel a vesting agreement
     * @param {SignToCancelVestingAgreementConfig} options
     */
    signToCancel(options?: SignToCancelVestingAgreementConfig): Promise<ArcTransactionResult>;
    /**
     * Revoke vote for cancelling a vesting agreement
     * @param {RevokeSignToCancelVestingAgreementConfig} options
     */
    revokeSignToCancel(options?: RevokeSignToCancelVestingAgreementConfig): Promise<ArcTransactionResult>;
    /**
     * Collects for a beneficiary, according to the agreement
     * @param {CollectVestingAgreementConfig} options
     */
    collect(options?: CollectVestingAgreementConfig): Promise<ArcTransactionResult>;
    /**
     * EntityFetcherFactory for votable Agreement.
     * @param avatarAddress
     */
    getVotableProposals(avatarAddress: Address): Promise<EntityFetcherFactory<AgreementProposal, SchemeProposalExecutedEventResult>>;
    /**
     * EntityFetcherFactory for executed proposals.
     * @param avatarAddress
     */
    getExecutedProposals(avatarAddress: Address): EntityFetcherFactory<VestingSchemeSchemeProposalExecuted, SchemeProposalExecutedEventResult>;
    /**
     * Returns a promise of the agreementId associated with the given proposal. The result
     * is 0 if the proposal has not been executed or is not found.
     * @param proposalId
     */
    getProposalAgreementId(proposalId: Hash): Promise<number>;
    getVotableProposal(avatarAddress: Address, proposalId: Hash): Promise<AgreementProposal>;
    getAgreement(agreementId: number): Promise<Agreement>;
    getParametersHash(params: StandardSchemeParams): Promise<Hash>;
    setParameters(params: StandardSchemeParams & TxGeneratingFunctionOptions): Promise<ArcTransactionDataResult<Hash>>;
    getDefaultPermissions(): SchemePermissions;
    getSchemePermissions(avatarAddress: Address): Promise<SchemePermissions>;
    getSchemeParameters(avatarAddress: Address): Promise<StandardSchemeParams>;
    getParameters(paramsHash: Hash): Promise<StandardSchemeParams>;
    protected hydrated(): void;
    private validateCreateParams(options);
    private convertProposalPropsArrayToObject(propsArray);
}
export declare class ArcTransactionAgreementResult extends ArcTransactionResult {
    constructor(tx: Hash, contract: any);
    /**
     * Returns promise of the agreement id from the logs of the mined transaction. Will watch for the mined tx,
     * so could take a while to return.
     */
    getAgreementIdFromMinedTx(): Promise<number>;
}
export declare const VestingSchemeFactory: ContractWrapperFactory<VestingSchemeWrapper>;
export interface AgreementProposalEventResult {
    /**
     * indexed
     */
    _avatar: Address;
    /**
     * indexed
     */
    _proposalId: Hash;
}
export interface NewVestedAgreementEventResult {
    /**
     * indexed
     */
    _agreementId: BigNumber.BigNumber;
}
export interface ProposedVestedAgreementEventResult {
    /**
     * indexed
     */
    _agreementId: BigNumber.BigNumber;
    /**
     * indexed
     */
    _proposalId: Hash;
}
export interface SignToCancelAgreementEventResult {
    /**
     * indexed
     */
    _agreementId: BigNumber.BigNumber;
    /**
     * indexed
     */
    _signer: Address;
}
export interface RevokeSignToCancelAgreementEventResult {
    /**
     * indexed
     */
    _agreementId: BigNumber.BigNumber;
    /**
     * indexed
     */
    _signer: Address;
}
export interface AgreementCancelEventResult {
    /**
     * indexed
     */
    _agreementId: BigNumber.BigNumber;
}
export interface CollectEventResult {
    /**
     * indexed
     */
    _agreementId: BigNumber.BigNumber;
}
export interface CommonVestingAgreementConfig {
    /**
     * Address of the recipient of the proposed agreement.
     */
    beneficiaryAddress: Address;
    /**
     * Where to send the tokens in case of cancellation
     */
    returnOnCancelAddress: Address;
    /**
     * Optional ethereum block number at which the agreement starts.
     * Default is the current block number.
     * Must be greater than or equal to zero.
     */
    startingBlock?: number;
    /**
     * The number of tokens to pay per period.
     * Period is calculated as (number of blocks / periodLength).
     * Should be expressed in Wei.
     * Must be greater than zero.
     */
    amountPerPeriod: BigNumber.BigNumber | string;
    /**
     * number of blocks in a period.
     * Must be greater than zero.
     */
    periodLength: number;
    /**
     * maximum number of periods that can be paid out.
     * Must be greater than zero.
     */
    numOfAgreedPeriods: number;
    /**
     * The minimum number of periods that must pass before the beneficiary
     * may collect tokens under the agreement.
     * Must be greater than or equal to zero.
     */
    cliffInPeriods: number;
    /**
     * The number of signatures required to cancel agreement.
     * See signToCancel.
     */
    signaturesReqToCancel: number;
    /**
     * An array of addresses of those who will be allowed to sign to cancel an agreement.
     * The length of this array must be greater than or equal to signaturesReqToCancel.
     */
    signers: Array<Address>;
}
export interface CreateVestingAgreementConfig extends CommonVestingAgreementConfig {
    /**
     * The address of the token that will be used to pay for the creation of the agreement.
     * The caller (msg.Sender) must have the funds to pay in that token.
     */
    token: string;
}
export interface ProposeVestingAgreementConfig extends CommonVestingAgreementConfig {
    /**
     * The address of the avatar in which the proposal is being be made.
     */
    avatar: Address;
}
export interface SignToCancelVestingAgreementConfig {
    /**
     * the agreementId
     */
    agreementId: number;
}
export interface RevokeSignToCancelVestingAgreementConfig {
    /**
     * the agreementId
     */
    agreementId: number;
}
export interface CollectVestingAgreementConfig {
    /**
     * the agreementId
     */
    agreementId: number;
}
export interface GetAgreementParams {
    /**
     * The address of the avatar
     */
    avatar: Address;
    /**
     * Optional agreement Id
     */
    agreementId?: number;
}
export interface AgreementProposal extends AgreementBase {
    /**
     * indexed
     */
    proposalId: Hash;
}
export interface Agreement extends AgreementBase {
    agreementId: number;
}
export interface AgreementBase {
    amountPerPeriod: BigNumber.BigNumber;
    beneficiaryAddress: Address;
    cliffInPeriods: BigNumber.BigNumber;
    collectedPeriods: BigNumber.BigNumber;
    numOfAgreedPeriods: BigNumber.BigNumber;
    periodLength: BigNumber.BigNumber;
    returnOnCancelAddress: Address;
    signaturesReqToCancel: BigNumber.BigNumber;
    startingBlock: BigNumber.BigNumber;
    tokenAddress: Address;
}
export interface VestingSchemeSchemeProposalExecuted extends SchemeProposalExecuted {
    agreementId: number;
}
