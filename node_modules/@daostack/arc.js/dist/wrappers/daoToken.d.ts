import { BigNumber } from "bignumber.js";
import { Address } from "../commonTypes";
import { ContractWrapperFactory } from "../contractWrapperFactory";
import { ArcTransactionResult, IContractWrapperFactory } from "../iContractWrapperBase";
import { TxGeneratingFunctionOptions } from "../transactionService";
import { EventFetcherFactory } from "../web3EventService";
import { BurnEventResult, IBurnableTokenWrapper } from "./iBurnableToken";
import { ApproveAndCallOptions, ChangeApprovalAndCallOptions, IErc827TokenWrapper, TransferAndCallOptions, TransferFromAndCallOptions } from "./iErc827Token";
import { MintableTokenWrapper } from "./mintableToken";
import { StandardTokenApproveOptions, StandardTokenChangeApprovalOptions, StandardTokenTransferFromOptions, StandardTokenTransferOptions } from "./standardToken";
export declare class DaoTokenWrapper extends MintableTokenWrapper implements IErc827TokenWrapper, IBurnableTokenWrapper {
    /**
     * Returns promise of DaoTokenWrapper on the global GEN token.
     */
    static getGenToken(): Promise<DaoTokenWrapper>;
    name: string;
    friendlyName: string;
    factory: IContractWrapperFactory<DaoTokenWrapper>;
    Burn: EventFetcherFactory<BurnEventResult>;
    /**
     * Mint tokens to recipient
     * @param options
     */
    mint(options: DaoTokenMintOptions & TxGeneratingFunctionOptions): Promise<ArcTransactionResult>;
    /**
     * Burn the given number of tokens
     * @param options
     */
    burn(options: DaoTokenBurnOptions & TxGeneratingFunctionOptions): Promise<ArcTransactionResult>;
    /**
     * Approve transfer of tokens by msg.sender (or `onBehalfOf`, if given)
     * from the given "spender".  Then call the function specified
     * by `callData`, all in a single transaction.
     * @param options
     */
    approveAndCall(options: ApproveAndCallOptions & TxGeneratingFunctionOptions): Promise<ArcTransactionResult>;
    /**
     * Transfer tokens from the current account to another.  Then call the function specified
     * by `callData`, all in a single transaction.
     * @param options
     */
    transferAndCall(options: TransferAndCallOptions & TxGeneratingFunctionOptions): Promise<ArcTransactionResult>;
    /**
     * Transfer tokens from one address to another.  Then call the function specified
     * by `callData`, all in a single transaction.
     * @param options
     */
    transferFromAndCall(options: TransferFromAndCallOptions & TxGeneratingFunctionOptions): Promise<ArcTransactionResult>;
    /**
     * Increase the number of tokens approved that msg.sender (or `onBehalfOf`, if given)
     * may transfer from the given "spender".
     * Then call the function specified by `callData`, all in a single transaction.
     * @param options
     */
    increaseApprovalAndCall(options: ChangeApprovalAndCallOptions & TxGeneratingFunctionOptions): Promise<ArcTransactionResult>;
    /**
     * Decrease the number of tokens approved that msg.sender (or `onBehalfOf` if given)
     * may transfer from the given "spender".
     * Then call the function specified by `callData`, all in a single transaction.
     * @param options
     */
    decreaseApprovalAndCall(options: ChangeApprovalAndCallOptions & TxGeneratingFunctionOptions): Promise<ArcTransactionResult>;
    getTokenName(): Promise<string>;
    getTokenSymbol(): Promise<string>;
    getTokenCap(): Promise<BigNumber>;
    approve(options: StandardTokenApproveOptions & TxGeneratingFunctionOptions): Promise<ArcTransactionResult>;
    transfer(options: StandardTokenTransferOptions & TxGeneratingFunctionOptions): Promise<ArcTransactionResult>;
    transferFrom(options: StandardTokenTransferFromOptions & TxGeneratingFunctionOptions): Promise<ArcTransactionResult>;
    increaseApproval(options: StandardTokenChangeApprovalOptions & TxGeneratingFunctionOptions): Promise<ArcTransactionResult>;
    finishMinting(options?: TxGeneratingFunctionOptions): Promise<ArcTransactionResult>;
    protected hydrated(): void;
}
/**
 * defined just to add good type checking
 */
export declare class DaoTokenFactoryType extends ContractWrapperFactory<DaoTokenWrapper> {
    deployed(): Promise<DaoTokenWrapper>;
    new(name: string, symbol: string, cap: BigNumber): Promise<DaoTokenWrapper>;
}
export declare const DaoTokenFactory: DaoTokenFactoryType;
export interface DaoTokenMintOptions {
    /**
     * The token recipient
     */
    recipient: Address;
    /**
     * Amount to mint
     */
    amount: BigNumber | string;
}
export interface DaoTokenBurnOptions {
    /**
     * Amount to burn
     */
    amount: BigNumber | string;
}
export interface AllowanceOptions {
    owner: Address;
    spender: Address;
}
