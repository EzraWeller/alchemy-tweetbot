"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const commonTypes_1 = require("../commonTypes");
const contractWrapperFactory_1 = require("../contractWrapperFactory");
const iContractWrapperBase_1 = require("../iContractWrapperBase");
const proposalGeneratorBase_1 = require("../proposalGeneratorBase");
const web3EventService_1 = require("../web3EventService");
class SchemeRegistrarWrapper extends proposalGeneratorBase_1.ProposalGeneratorBase {
    constructor() {
        super(...arguments);
        this.name = "SchemeRegistrar";
        this.friendlyName = "Scheme Registrar";
        this.factory = exports.SchemeRegistrarFactory;
    }
    /**
     * Submit a proposal to add or modify a given scheme.
     * @param options
     */
    proposeToAddModifyScheme(options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const defaults = {
                permissions: null,
                schemeName: null,
            };
            options = Object.assign({}, defaults, options);
            if (!options.avatar) {
                throw new Error("avatar is not defined");
            }
            if (!options.schemeAddress) {
                throw new Error("schemeAddress is not defined");
            }
            if (!options.schemeParametersHash) {
                throw new Error("schemeParametersHash is not defined");
            }
            /**
             * throws an Error if not valid, yields 0 if null or undefined
             */
            let permissions;
            if (options.schemeName) {
                /**
                 * then we are adding/removing an Arc scheme and can get and check its permissions.
                 */
                permissions = options.permissions || commonTypes_1.DefaultSchemePermissions[options.schemeName];
                if (permissions > this.getDefaultPermissions()) {
                    throw new Error("SchemeRegistrar cannot work with schemes having greater permissions than its own");
                }
            }
            else {
                permissions = options.permissions;
                if (!permissions) {
                    throw new Error("permissions is not defined; it is required for non-Arc schemes (where schemeName is undefined)");
                }
            }
            this.logContractFunctionCall("SchemeRegistrar.proposeScheme", options);
            const txResult = yield this.wrapTransactionInvocation("SchemeRegistrar.proposeToAddModifyScheme", options, this.contract.proposeScheme, [options.avatar,
                options.schemeAddress,
                options.schemeParametersHash,
                commonTypes_1.SchemePermissions.toString(permissions)]);
            return new iContractWrapperBase_1.ArcTransactionProposalResult(txResult.tx, this.contract, yield this.getVotingMachine(options.avatar));
        });
    }
    /**
     * Submit a proposal to remove a given scheme.
     * @param options
     */
    proposeToRemoveScheme(options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!options.avatar) {
                throw new Error("avatar is not defined");
            }
            if (!options.schemeAddress) {
                throw new Error("schemeAddress address is not defined");
            }
            this.logContractFunctionCall("SchemeRegistrar.proposeToRemoveScheme", options);
            const txResult = yield this.wrapTransactionInvocation("SchemeRegistrar.proposeToRemoveScheme", options, this.contract.proposeToRemoveScheme, [options.avatar,
                options.schemeAddress]);
            return new iContractWrapperBase_1.ArcTransactionProposalResult(txResult.tx, this.contract, yield this.getVotingMachine(options.avatar));
        });
    }
    getParametersHash(params) {
        return this._getParametersHash(params.voteParametersHash, params.voteRemoveParametersHash ? params.voteRemoveParametersHash : params.voteParametersHash, params.votingMachineAddress);
    }
    setParameters(params) {
        this.validateStandardSchemeParams(params);
        return super._setParameters("SchemeRegistrar.setParameters", params.txEventContext, params.voteParametersHash, params.voteRemoveParametersHash ? params.voteRemoveParametersHash : params.voteParametersHash, params.votingMachineAddress);
    }
    getDefaultPermissions() {
        return commonTypes_1.DefaultSchemePermissions.SchemeRegistrar;
    }
    getSchemePermissions(avatarAddress) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this._getSchemePermissions(avatarAddress);
        });
    }
    getSchemeParameters(avatarAddress) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this._getSchemeParameters(avatarAddress);
        });
    }
    getParameters(paramsHash) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const params = yield this.getParametersArray(paramsHash);
            return {
                voteParametersHash: params[0],
                voteRemoveParametersHash: params[1],
                votingMachineAddress: params[2],
            };
        });
    }
    /**
     * EntityFetcherFactory for votable SchemeRegistrarProposal.
     * @param avatarAddress
     */
    getVotableAddSchemeProposals(avatarAddress) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!avatarAddress) {
                throw new Error("avatarAddress is not set");
            }
            return this.proposalService.getProposalEvents({
                baseArgFilter: { _avatar: avatarAddress },
                proposalsEventFetcher: this.NewSchemeProposal,
                transformEventCallback: (event) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    return this.getVotableProposal(event.args._avatar, event.args._proposalId);
                }),
                votableOnly: true,
                votingMachine: yield this.getVotingMachine(avatarAddress),
            });
        });
    }
    /**
     * EntityFetcherFactory for votable SchemeRegistrarProposal.
     * @param avatarAddress
     */
    getVotableRemoveSchemeProposals(avatarAddress) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!avatarAddress) {
                throw new Error("avatarAddress is not set");
            }
            return this.proposalService.getProposalEvents({
                baseArgFilter: { _avatar: avatarAddress },
                proposalsEventFetcher: this.RemoveSchemeProposal,
                transformEventCallback: (event) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    return this.getVotableProposal(event.args._avatar, event.args._proposalId);
                }),
                votableOnly: true,
                votingMachine: yield this.getVotingMachine(avatarAddress),
            });
        });
    }
    /**
     * EntityFetcherFactory for executed proposals.
     * @param avatarAddress
     */
    getExecutedProposals(avatarAddress) {
        return this.proposalService.getProposalEvents({
            baseArgFilter: { _avatar: avatarAddress },
            proposalsEventFetcher: this.ProposalExecuted,
            transformEventCallback: (event) => {
                return Promise.resolve({
                    avatarAddress: event.args._avatar,
                    proposalId: event.args._proposalId,
                    winningVote: event.args._param,
                });
            },
        });
    }
    getVotableProposal(avatarAddress, proposalId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const proposalParams = yield this.contract.organizationsProposals(avatarAddress, proposalId);
            return this.convertProposalPropsArrayToObject(proposalParams, proposalId);
        });
    }
    hydrated() {
        /* tslint:disable:max-line-length */
        this.NewSchemeProposal = this.createEventFetcherFactory(this.contract.NewSchemeProposal);
        this.RemoveSchemeProposal = this.createEventFetcherFactory(this.contract.RemoveSchemeProposal);
        this.ProposalExecuted = this.createEventFetcherFactory(this.contract.ProposalExecuted);
        this.ProposalDeleted = this.createEventFetcherFactory(this.contract.ProposalDeleted);
        /* tslint:enable:max-line-length */
    }
    convertProposalPropsArrayToObject(propsArray, proposalId) {
        return {
            parametersHash: propsArray[1],
            permissions: commonTypes_1.SchemePermissions.fromString(propsArray[3]),
            proposalId,
            proposalType: propsArray[2].toNumber(),
            schemeAddress: propsArray[0],
        };
    }
}
exports.SchemeRegistrarWrapper = SchemeRegistrarWrapper;
exports.SchemeRegistrarFactory = new contractWrapperFactory_1.ContractWrapperFactory("SchemeRegistrar", SchemeRegistrarWrapper, new web3EventService_1.Web3EventService());
var SchemeRegistrarProposalType;
(function (SchemeRegistrarProposalType) {
    SchemeRegistrarProposalType[SchemeRegistrarProposalType["Add"] = 1] = "Add";
    SchemeRegistrarProposalType[SchemeRegistrarProposalType["Remove"] = 2] = "Remove";
})(SchemeRegistrarProposalType = exports.SchemeRegistrarProposalType || (exports.SchemeRegistrarProposalType = {}));
//# sourceMappingURL=schemeRegistrar.js.map