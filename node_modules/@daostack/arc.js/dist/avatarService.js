"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const es6_promisify_1 = require("es6-promisify");
const controllerService_1 = require("./controllerService");
const loggingService_1 = require("./loggingService");
const utils_1 = require("./utils");
const daoToken_1 = require("./wrappers/daoToken");
const reputation_1 = require("./wrappers/reputation");
/**
 * Methods for querying information about an Avatar.
 * Use it by:
 *
 * let avatarService = new AvatarService(avatarAddress);
 *
 */
class AvatarService {
    constructor(avatarAddress) {
        this.avatarAddress = avatarAddress;
        this.controllerService = new controllerService_1.ControllerService(avatarAddress);
    }
    /**
     * Returns promise of the Avatar Truffle contract wrapper.
     * Returns undefined if not found.
     */
    getAvatar() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.avatar) {
                const Avatar = yield utils_1.Utils.requireContract("Avatar");
                return Avatar.at(this.avatarAddress)
                    .then((avatar) => avatar) // only way to get to catch
                    /* have to handle the catch or promise rejection goes unhandled */
                    .catch((ex) => {
                    loggingService_1.LoggingService.error(`AvatarService: unable to load avatar at ${this.avatarAddress}: ${ex.message}`);
                    return undefined;
                });
            }
        });
    }
    getIsUController() {
        return this.controllerService.getIsUController();
    }
    /**
     * Returns promise of the address of the controller
     */
    getControllerAddress() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.controllerService.getControllerAddress();
        });
    }
    /**
     * Returns promise of a Truffle contract wrapper for the controller.  Could be
     * either UController or Controller.  You can know which one
     * by called `getIsUController`.
     */
    getController() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.controllerService.getController();
        });
    }
    /**
     * Returns promise of the address of the avatar's native reputation.
     */
    getNativeReputationAddress() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.nativeReputationAddress) {
                const avatar = yield this.getAvatar();
                if (avatar) {
                    this.nativeReputationAddress = yield avatar.nativeReputation();
                }
            }
            return this.nativeReputationAddress;
        });
    }
    /**
     * Returns promise of the avatar's native reputation Truffle contract wrapper.
     */
    getNativeReputation() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.nativeReputation) {
                const reputationAddress = yield this.getNativeReputationAddress();
                if (reputationAddress) {
                    this.nativeReputation = yield reputation_1.ReputationFactory.at(reputationAddress);
                }
            }
            return this.nativeReputation;
        });
    }
    /**
     * Returns promise of the address of the avatar's native token.
     */
    getNativeTokenAddress() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.nativeTokenAddress) {
                const avatar = yield this.getAvatar();
                if (avatar) {
                    this.nativeTokenAddress = yield avatar.nativeToken();
                }
            }
            return this.nativeTokenAddress;
        });
    }
    /**
     * Returns promise of the avatar's native token Truffle contract wrapper.
     * Assumes the token is a `DAOToken`.
     */
    getNativeToken() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.nativeToken) {
                const tokenAddress = yield this.getNativeTokenAddress();
                if (tokenAddress) {
                    this.nativeToken = yield daoToken_1.DaoTokenFactory.at(tokenAddress);
                }
            }
            return this.nativeToken;
        });
    }
    /**
     * Return a current token balance for this avatar, in Wei.
     * If tokenAddress is not supplied, then uses native token.
     */
    getTokenBalance(tokenAddress) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let token;
            if (!tokenAddress) {
                token = yield this.getNativeToken();
            }
            else {
                token = yield daoToken_1.DaoTokenFactory.at(tokenAddress);
            }
            if (!token) {
                loggingService_1.LoggingService.error(`AvatarService: Unable to load token at ${tokenAddress}`);
                return Promise.resolve(undefined);
            }
            return token.getBalanceOf(this.avatarAddress);
        });
    }
    /**
     * Return the current ETH balance for this avatar, in Wei.
     */
    getEthBalance() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const web3 = yield utils_1.Utils.getWeb3();
            return es6_promisify_1.promisify((callback) => web3.eth.getBalance(this.avatarAddress, web3.eth.defaultBlock, callback))()
                .then((balance) => {
                return balance;
            });
        });
    }
}
exports.AvatarService = AvatarService;
//# sourceMappingURL=avatarService.js.map