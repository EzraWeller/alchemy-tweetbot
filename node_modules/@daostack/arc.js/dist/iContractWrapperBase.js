"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const transactionService_1 = require("./transactionService");
class ArcTransactionResult {
    constructor(
    /**
     * The transaction hash
     */
    tx, 
    /**
     *  the Truffle contract wrapper
     */
    contract) {
        this.tx = tx;
        this.contract = contract;
    }
    /**
     * Returns a promise of the transaction if it is mined,
     * converted to a TransactionReceiptTruffle (with readable logs).
     *
     * Returns null if the transaciton is not yet mined.
     */
    getTxMined() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.tx) {
                return null;
            }
            return transactionService_1.TransactionService.getMinedTransaction(this.tx, this.contract);
        });
    }
    /**
     * Returns a promise of the transaction if it is confirmed,
     * converted to a TransactionReceiptTruffle (with readable logs).
     *
     * Returns null if the transaction is not yet found at the required depth.
     *
     * @param requiredDepth Optional minimum block depth required to resolve the promise.
     * Default comes from the `ConfigurationService`.
     */
    getTxConfirmed(requiredDepth) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.tx) {
                return null;
            }
            return transactionService_1.TransactionService.getConfirmedTransaction(this.tx, this.contract, requiredDepth);
        });
    }
    /**
     * Returns promise of a mined transaction once it has been mined,
     * converted to a TransactionReceiptTruffle (with readable logs).
     */
    watchForTxMined() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.tx) {
                return null;
            }
            return transactionService_1.TransactionService.watchForMinedTransaction(this.tx, this.contract);
        });
    }
    /**
     * Returns a promise of a TransactionReceipt once the given transaction has been confirmed,
     * converted to a TransactionReceiptTruffle (with readable logs),
     * according to the optional `requiredDepth`.
     *
     * @param requiredDepth Optional minimum block depth required to resolve the promise.
     * Default comes from the `ConfigurationService`.
     */
    watchForTxConfirmed(requiredDepth) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.tx) {
                return null;
            }
            return transactionService_1.TransactionService.watchForConfirmedTransaction(this.tx, this.contract, requiredDepth);
        });
    }
    /**
     * Returns promise of a value from the logs of the mined transaction. Will watch for the mined tx,
     * so could take a while to return.
     * @param valueName - The name of the property whose value we wish to return
     * @param eventName - Name of the event in whose log we are to look for the value
     * @param index - Index of the log in which to look for the value, when eventName is not given.
     * Default is the index of the last log in the transaction.
     */
    getValueFromMinedTx(valueName, eventName = null, index = 0) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.tx) {
                return null;
            }
            const txMined = yield this.watchForTxMined();
            return transactionService_1.TransactionService.getValueFromLogs(txMined, valueName, eventName, index);
        });
    }
}
exports.ArcTransactionResult = ArcTransactionResult;
/**
 * Base or actual type returned by all contract wrapper methods that generate a transaction and initiate a proposal.
 */
class ArcTransactionProposalResult extends ArcTransactionResult {
    constructor(tx, contract, 
    /**
     * The proposal's voting machine, as IntVoteInterface
     */
    votingMachine) {
        super(tx, contract);
        this.votingMachine = votingMachine;
        this.votingMachine = votingMachine;
    }
    /**
     * Returns promise of the proposal id from the logs of the mined transaction. Will watch for the mined tx;
     * if it hasn't yet been mined, could take a while to return.
     */
    getProposalIdFromMinedTx() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.getValueFromMinedTx("_proposalId");
        });
    }
}
exports.ArcTransactionProposalResult = ArcTransactionProposalResult;
/**
 * Base or actual type returned by all contract wrapper methods that generate a transaction and any other result.
 */
class ArcTransactionDataResult extends ArcTransactionResult {
    constructor(tx, contract, 
    /**
     * Additional data being returned.
     */
    result) {
        super(tx, contract);
        this.result = result;
        this.result = result;
    }
}
exports.ArcTransactionDataResult = ArcTransactionDataResult;
//# sourceMappingURL=iContractWrapperBase.js.map