import { BigNumber } from "bignumber.js";
import { Address, Hash, SchemePermissions } from "../commonTypes";
import { ContractWrapperFactory } from "../contractWrapperFactory";
import { ArcTransactionDataResult, ArcTransactionProposalResult, IContractWrapperFactory, IUniversalSchemeWrapper, StandardSchemeParams } from "../iContractWrapperBase";
import { ProposalGeneratorBase } from "../proposalGeneratorBase";
import { TxGeneratingFunctionOptions } from "../transactionService";
import { EntityFetcherFactory, EventFetcherFactory } from "../web3EventService";
import { ProposalDeletedEventResult, SchemeProposalExecuted, SchemeProposalExecutedEventResult } from "./commonEventInterfaces";
export declare class VoteInOrganizationSchemeWrapper extends ProposalGeneratorBase implements IUniversalSchemeWrapper {
    name: string;
    friendlyName: string;
    factory: IContractWrapperFactory<VoteInOrganizationSchemeWrapper>;
    /**
     * Events
     */
    NewVoteProposal: EventFetcherFactory<NewVoteProposalEventResult>;
    ProposalExecuted: EventFetcherFactory<SchemeProposalExecutedEventResult>;
    ProposalDeleted: EventFetcherFactory<ProposalDeletedEventResult>;
    VoteOnBehalf: EventFetcherFactory<VoteOnBehalfEventResult>;
    /**
     * Submit a proposal to vote on a proposal in another DAO.
     * @param options
     */
    proposeVoteInOrganization(options?: VoteInOrganizationProposeVoteConfig): Promise<ArcTransactionProposalResult>;
    /**
     * EntityFetcherFactory for votable VoteInOrganizationProposal.
     * @param avatarAddress
     */
    getVotableProposals(avatarAddress: Address): Promise<EntityFetcherFactory<VotableVoteInOrganizationProposal, NewVoteProposalEventResult>>;
    /**
     * EntityFetcherFactory for executed proposals.
     * @param avatarAddress
     */
    getExecutedProposals(avatarAddress: Address): EntityFetcherFactory<SchemeProposalExecuted, SchemeProposalExecutedEventResult>;
    getVotableProposal(avatarAddress: Address, proposalId: Hash): Promise<VotableVoteInOrganizationProposal>;
    getParametersHash(params: StandardSchemeParams): Promise<Hash>;
    setParameters(params: StandardSchemeParams & TxGeneratingFunctionOptions): Promise<ArcTransactionDataResult<Hash>>;
    getDefaultPermissions(): SchemePermissions;
    getSchemePermissions(avatarAddress: Address): Promise<SchemePermissions>;
    getSchemeParameters(avatarAddress: Address): Promise<StandardSchemeParams>;
    getParameters(paramsHash: Hash): Promise<StandardSchemeParams>;
    protected hydrated(): void;
    private convertProposalPropsArrayToObject(propsArray, proposalId);
}
export declare const VoteInOrganizationSchemeFactory: ContractWrapperFactory<VoteInOrganizationSchemeWrapper>;
export interface VoteOnBehalfEventResult {
    _params: Array<Hash>;
}
export interface VoteInOrganizationProposeVoteConfig {
    /**
     * Avatar whose voters are being given the chance to vote on the original proposal.
     */
    avatar: Address;
    /**
     * Address of the voting machine used by the original proposal.  The voting machine must
     * implement IntVoteInterface (as defined in Arc).
     */
    originalVotingMachineAddress: Address;
    /**
     * Address of the "original" proposal for which the DAO's vote will cast.
     */
    originalProposalId: string;
}
export interface VotableVoteInOrganizationProposal {
    originalVotingMachineAddress: Address;
    originalNumOfChoices: number;
    originalProposalId: Hash;
    proposalId: Hash;
}
export interface NewVoteProposalEventResult {
    /**
     * indexed
     */
    _avatar: Address;
    /**
     * indexed
     */
    _intVoteInterface: Address;
    _originalIntVote: Address;
    _originalProposalId: Hash;
    _originalNumOfChoices: BigNumber;
    /**
     * indexed
     */
    _proposalId: Hash;
}
