import { Address, Hash, SchemePermissions } from "./commonTypes";
import { ArcTransactionDataResult, ArcTransactionResult, IContractWrapper, IContractWrapperFactory, StandardSchemeParams } from "./iContractWrapperBase";
import { TxEventContext, TxGeneratingFunctionOptions } from "./transactionService";
import { EventFetcherFactory, Web3EventService } from "./web3EventService";
/**
 * Abstract base class for all Arc contract wrapper classes.
 *
 * Example of how to define a wrapper:
 *
 * ```
 * import { ContractWrapperBase } from "../contractWrapperBase";
 * import { ContractWrapperFactory } from "../contractWrapperFactory";
 *
 * export class AbsoluteVoteWrapper extends ContractWrapperBase {
 *   [ wrapper properties and methods ]
 * }
 *
 * export const AbsoluteVote = new ContractWrapperFactory(
 *  "AbsoluteVote",
 *  AbsoluteVoteWrapper,
 *  new Web3EventService());
 * ```
 */
export declare abstract class ContractWrapperBase implements IContractWrapper {
    private solidityContract;
    protected web3EventService: Web3EventService;
    /**
     * The wrapper factor class providing static methods `at(someAddress)`, `new()` and `deployed()`.
     */
    abstract factory: IContractWrapperFactory<any>;
    /**
     * The name of the contract.
     */
    abstract name: string;
    /**
     * A more friendly name for the contract.
     */
    abstract friendlyName: string;
    /**
     * The address of the contract
     */
    readonly address: Address;
    /**
     * The underlying truffle contract object.  Use this to access
     * parts of the contract that aren't accessible via the wrapper.
     */
    contract: any;
    /**
     * ContractWrapperFactory constructs this
     * @param solidityContract The json contract truffle artifact
     * @param web3EventService
     */
    constructor(solidityContract: any, web3EventService: Web3EventService);
    /**
     * Initialize from a newly-migrated instance.
     * This will migrate a new instance of the contract to the net.
     * @returns this
     */
    hydrateFromNew(...rest: Array<any>): Promise<IContractWrapper>;
    /**
     * Initialize from a given address on the current network.
     * @param address of the deployed contract
     * @returns this or undefined if not found
     */
    hydrateFromAt(address: string): Promise<IContractWrapper>;
    /**
     * Initialize as it was migrated by Arc.js on the current network.
     * @returns this or undefined if not found
     */
    hydrateFromDeployed(): Promise<IContractWrapper>;
    /**
     * Given a hash, returns the associated parameters as an object.
     * @param paramsHash
     */
    getParameters(paramsHash: Hash): Promise<any>;
    /**
     * Given an avatar address, returns the schemes parameters hash
     * @param avatarAddress
     */
    getSchemeParametersHash(avatarAddress: Address): Promise<Hash>;
    /**
     * Given a hash, returns the associated parameters as an array, ordered by the order
     * in which the parameters appear in the contract's Parameters struct.
     * @param paramsHash
     */
    getParametersArray(paramsHash: Hash): Promise<Array<any>>;
    /**
     * Returns the controller associated with the given avatar
     * @param avatarAddress
     */
    getController(avatarAddress: Address): Promise<any>;
    /**
     * Estimate conservatively the amount of gas required to execute the given function with the given parameters.
     * Adds 21000 to the estimate computed by web3.
     *
     * @param func The function
     * @param params The parameters to send to the function
     * @param web3Params The web3 parameters (like "from", for example).  If it contains "gas"
     * then that value is returned, effectively a no-op.
     */
    estimateGas(func: ITruffleContractFunction, params: Array<any>, web3Params?: any): Promise<number>;
    /**
     * invoked to let base classes know that the `contract` is available.
     */
    protected hydrated(): void;
    protected _setParameters(functionName: string, txEventContext: TxEventContext, ...params: Array<any>): Promise<ArcTransactionDataResult<Hash>>;
    /**
     * Returns this scheme's permissions.
     * @param avatarAddress
     */
    protected _getSchemePermissions(avatarAddress: Address): Promise<SchemePermissions>;
    protected _getSchemeParameters(avatarAddress: Address): Promise<any>;
    protected _getParametersHash(...params: Array<any>): Promise<Hash>;
    /**
     * See [Web3EventService.createEventFetcherFactory](Web3EventService#createEventFetcherFactory).
     *
     * @type TArgs
     * @param eventName
     */
    protected createEventFetcherFactory<TArgs>(baseEvent: any): EventFetcherFactory<TArgs>;
    protected validateStandardSchemeParams(params: StandardSchemeParams): void;
    /**
     * Wrap code that creates a transaction in the given transaction event. This is a helper
     * just for the common case of generating a single transaction.
     * Rethrows exceptions that occur.
     *
     * @param functionName Should look like [contractName].[functionName]
     * @param options Options that will be passed in the event payload, and
     * potentially containing a txEventContext
     * @param generateTx Callback that will  the contract function
     * @param func The contract function
     * @param params The contract function parameters
     * @param web3Params Optional web params, like `from`
     */
    protected wrapTransactionInvocation(functionName: string, options: Partial<TxGeneratingFunctionOptions> & any, func: ITruffleContractFunction, params: Array<any>, web3Params?: any): Promise<ArcTransactionResult>;
    /**
     * Invoke sendTransaction on the function.  Properly publish TxTracking events.
     * Rethrows exceptions that occur.
     *
     * If `ConfigService.get("estimateGas")` and gas was not already supplied,
     * then we estimate gas.
     *
     * @param eventContext The TxTracking context
     * @param func The contract function
     * @param params The contract function parameters
     * @param web3Params Optional web params, like `from`
     */
    protected sendTransaction(eventContext: TxEventContext, func: ITruffleContractFunction, params: Array<any>, web3Params?: any): Promise<Hash>;
    protected logContractFunctionCall(functionName: string, params?: any): void;
}
export declare type TruffleContractFunction = (args?: Array<any>) => Promise<Hash>;
export interface ITruffleContractFunction extends TruffleContractFunction {
    sendTransaction: (args?: Array<any>) => Promise<Hash>;
    estimateGas: (args?: Array<any>) => number;
}
