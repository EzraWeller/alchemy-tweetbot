"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const commonTypes_1 = require("../commonTypes");
const iContractWrapperBase_1 = require("../iContractWrapperBase");
const contractWrapperFactory_1 = require("../contractWrapperFactory");
const proposalGeneratorBase_1 = require("../proposalGeneratorBase");
const web3EventService_1 = require("../web3EventService");
class UpgradeSchemeWrapper extends proposalGeneratorBase_1.ProposalGeneratorBase {
    constructor() {
        super(...arguments);
        this.name = "UpgradeScheme";
        this.friendlyName = "Upgrade Scheme";
        this.factory = exports.UpgradeSchemeFactory;
    }
    /**
     * Submit a proposal to change the DAO's controller.
     * @param options
     */
    proposeController(options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!options.avatar) {
                throw new Error("avatar address is not defined");
            }
            if (!options.controller) {
                throw new Error("controller address is not defined");
            }
            this.logContractFunctionCall("UpgradeScheme.proposeUpgrade", options);
            const txResult = yield this.wrapTransactionInvocation("UpgradeScheme.proposeController", options, this.contract.proposeUpgrade, [options.avatar,
                options.controller]);
            return new iContractWrapperBase_1.ArcTransactionProposalResult(txResult.tx, this.contract, yield this.getVotingMachine(options.avatar));
        });
    }
    /**
     * Submit a proposal to change or modify the DAO's upgrading scheme.
     * @param options
     */
    proposeUpgradingScheme(options = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!options.avatar) {
                throw new Error("avatar address is not defined");
            }
            if (!options.scheme) {
                throw new Error("scheme is not defined");
            }
            if (!options.schemeParametersHash) {
                throw new Error("schemeParametersHash is not defined");
            }
            this.logContractFunctionCall("UpgradeScheme.proposeUpgradingScheme", options);
            const txResult = yield this.wrapTransactionInvocation("UpgradeScheme.proposeUpgradingScheme", options, this.contract.proposeChangeUpgradingScheme, [options.avatar,
                options.scheme,
                options.schemeParametersHash]);
            return new iContractWrapperBase_1.ArcTransactionProposalResult(txResult.tx, this.contract, yield this.getVotingMachine(options.avatar));
        });
    }
    getParametersHash(params) {
        return this._getParametersHash(params.voteParametersHash, params.votingMachineAddress);
    }
    setParameters(params) {
        this.validateStandardSchemeParams(params);
        return super._setParameters("UpgradeScheme.setParameters", params.txEventContext, params.voteParametersHash, params.votingMachineAddress);
    }
    getDefaultPermissions() {
        return commonTypes_1.DefaultSchemePermissions.UpgradeScheme;
    }
    getSchemePermissions(avatarAddress) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this._getSchemePermissions(avatarAddress);
        });
    }
    getSchemeParameters(avatarAddress) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this._getSchemeParameters(avatarAddress);
        });
    }
    getParameters(paramsHash) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const params = yield this.getParametersArray(paramsHash);
            return {
                voteParametersHash: params[0],
                votingMachineAddress: params[1],
            };
        });
    }
    /**
     * EntityFetcherFactory for votable UpgradeSchemeProposal.
     * @param avatarAddress
     */
    getVotableUpgradeUpgradeSchemeProposals(avatarAddress) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.proposalService.getProposalEvents({
                baseArgFilter: { _avatar: avatarAddress },
                proposalsEventFetcher: this.ChangeUpgradeSchemeProposal,
                transformEventCallback: (event) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    return this.getVotableProposal(event.args._avatar, event.args._proposalId);
                }),
                votableOnly: true,
                votingMachine: yield this.getVotingMachine(avatarAddress),
            });
        });
    }
    /**
     * EntityFetcherFactory for votable UpgradeSchemeProposal.
     * @param avatarAddress
     */
    getVotableUpgradeControllerProposals(avatarAddress) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.proposalService.getProposalEvents({
                baseArgFilter: { _avatar: avatarAddress },
                proposalsEventFetcher: this.NewUpgradeProposal,
                transformEventCallback: (event) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    return this.getVotableProposal(event.args._avatar, event.args._proposalId);
                }),
                votableOnly: true,
                votingMachine: yield this.getVotingMachine(avatarAddress),
            });
        });
    }
    /**
     * EntityFetcherFactory for executed proposals.
     * @param avatarAddress
     */
    getExecutedProposals(avatarAddress) {
        return this.proposalService.getProposalEvents({
            baseArgFilter: { _avatar: avatarAddress },
            proposalsEventFetcher: this.ProposalExecuted,
            transformEventCallback: (event) => {
                return Promise.resolve({
                    avatarAddress: event.args._avatar,
                    proposalId: event.args._proposalId,
                    winningVote: event.args._param,
                });
            },
        });
    }
    getVotableProposal(avatarAddress, proposalId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const proposalParams = yield this.contract.organizationsProposals(avatarAddress, proposalId);
            return this.convertProposalPropsArrayToObject(proposalParams, proposalId);
        });
    }
    hydrated() {
        /* tslint:disable:max-line-length */
        this.NewUpgradeProposal = this.createEventFetcherFactory(this.contract.NewUpgradeProposal);
        this.ChangeUpgradeSchemeProposal = this.createEventFetcherFactory(this.contract.ChangeUpgradeSchemeProposal);
        this.ProposalExecuted = this.createEventFetcherFactory(this.contract.ProposalExecuted);
        this.ProposalDeleted = this.createEventFetcherFactory(this.contract.ProposalDeleted);
        /* tslint:enable:max-line-length */
    }
    convertProposalPropsArrayToObject(propsArray, proposalId) {
        return {
            paramsUpgradingScheme: propsArray[1],
            proposalId,
            proposalType: propsArray[2].toNumber(),
            upgradeContractAddress: propsArray[0],
        };
    }
}
exports.UpgradeSchemeWrapper = UpgradeSchemeWrapper;
exports.UpgradeSchemeFactory = new contractWrapperFactory_1.ContractWrapperFactory("UpgradeScheme", UpgradeSchemeWrapper, new web3EventService_1.Web3EventService());
var UpgradeSchemeProposalType;
(function (UpgradeSchemeProposalType) {
    UpgradeSchemeProposalType[UpgradeSchemeProposalType["Controller"] = 1] = "Controller";
    UpgradeSchemeProposalType[UpgradeSchemeProposalType["UpgradeScheme"] = 2] = "UpgradeScheme";
})(UpgradeSchemeProposalType = exports.UpgradeSchemeProposalType || (exports.UpgradeSchemeProposalType = {}));
//# sourceMappingURL=upgradeScheme.js.map