import BigNumber from "bignumber.js";
import { Address, Hash, SchemePermissions } from "./commonTypes";
import { TransactionReceiptTruffle } from "./transactionService";
import { IIntVoteInterface } from "./wrappers/iIntVoteInterface";
export interface IContractWrapper {
    factory: IContractWrapperFactory<any>;
    name: string;
    friendlyName: string;
    address: Address;
    contract: any;
    hydrateFromNew(...rest: Array<any>): Promise<any>;
    hydrateFromAt(address: string): Promise<any>;
    hydrateFromDeployed(): Promise<any>;
}
/**
 * The minimum requirements for a scheme that can be registered with a DAO/controller.
 */
export interface ISchemeWrapper extends IContractWrapper {
    getSchemePermissions(avatarAddress: Address): Promise<SchemePermissions>;
    getDefaultPermissions(): SchemePermissions;
}
/**
 * The minimum requirements for a universal scheme.
 */
export interface IUniversalSchemeWrapper extends ISchemeWrapper {
    getParameters(paramsHash: Hash): Promise<any>;
    getParametersHash(params: any): Promise<Hash>;
    setParameters(params: any): Promise<ArcTransactionDataResult<Hash>>;
    getSchemeParameters(avatarAddress: Address): Promise<any>;
    getParametersArray(paramsHash: Hash): Promise<Array<any>>;
    getController(avatarAddress: Address): Promise<any>;
}
/**
 * The minimum requirements for a voting machine wrapper.
 */
export interface IVotingMachineWrapper extends IContractWrapper {
    getParameters(paramsHash: Hash): Promise<any>;
    getParametersHash(params: any): Promise<Hash>;
    setParameters(params: any): Promise<ArcTransactionDataResult<Hash>>;
    getParametersArray(paramsHash: Hash): Promise<Array<any>>;
}
export interface IContractWrapperFactory<TWrapper extends IContractWrapper> {
    new: (...rest: Array<any>) => Promise<TWrapper>;
    at: (address: string) => Promise<TWrapper>;
    deployed: () => Promise<TWrapper>;
}
export declare class ArcTransactionResult {
    /**
     * The transaction hash
     */
    tx: Hash;
    /**
     *  the Truffle contract wrapper
     */
    private contract;
    constructor(
        /**
         * The transaction hash
         */
        tx: Hash, 
        /**
         *  the Truffle contract wrapper
         */
        contract: string | object);
    /**
     * Returns a promise of the transaction if it is mined,
     * converted to a TransactionReceiptTruffle (with readable logs).
     *
     * Returns null if the transaciton is not yet mined.
     */
    getTxMined(): Promise<TransactionReceiptTruffle | null>;
    /**
     * Returns a promise of the transaction if it is confirmed,
     * converted to a TransactionReceiptTruffle (with readable logs).
     *
     * Returns null if the transaction is not yet found at the required depth.
     *
     * @param requiredDepth Optional minimum block depth required to resolve the promise.
     * Default comes from the `ConfigurationService`.
     */
    getTxConfirmed(requiredDepth?: number): Promise<TransactionReceiptTruffle | null>;
    /**
     * Returns promise of a mined transaction once it has been mined,
     * converted to a TransactionReceiptTruffle (with readable logs).
     */
    watchForTxMined(): Promise<TransactionReceiptTruffle>;
    /**
     * Returns a promise of a TransactionReceipt once the given transaction has been confirmed,
     * converted to a TransactionReceiptTruffle (with readable logs),
     * according to the optional `requiredDepth`.
     *
     * @param requiredDepth Optional minimum block depth required to resolve the promise.
     * Default comes from the `ConfigurationService`.
     */
    watchForTxConfirmed(requiredDepth?: number): Promise<TransactionReceiptTruffle>;
    /**
     * Returns promise of a value from the logs of the mined transaction. Will watch for the mined tx,
     * so could take a while to return.
     * @param valueName - The name of the property whose value we wish to return
     * @param eventName - Name of the event in whose log we are to look for the value
     * @param index - Index of the log in which to look for the value, when eventName is not given.
     * Default is the index of the last log in the transaction.
     */
    getValueFromMinedTx(valueName: string, eventName?: string, index?: number): Promise<any | undefined>;
}
/**
 * Base or actual type returned by all contract wrapper methods that generate a transaction and initiate a proposal.
 */
export declare class ArcTransactionProposalResult extends ArcTransactionResult {
    /**
     * The proposal's voting machine, as IntVoteInterface
     */
    votingMachine: IIntVoteInterface;
    constructor(tx: Hash, contract: any, 
        /**
         * The proposal's voting machine, as IntVoteInterface
         */
        votingMachine: IIntVoteInterface);
    /**
     * Returns promise of the proposal id from the logs of the mined transaction. Will watch for the mined tx;
     * if it hasn't yet been mined, could take a while to return.
     */
    getProposalIdFromMinedTx(): Promise<Hash>;
}
/**
 * Base or actual type returned by all contract wrapper methods that generate a transaction and any other result.
 */
export declare class ArcTransactionDataResult<TData> extends ArcTransactionResult {
    /**
     * Additional data being returned.
     */
    result: TData;
    constructor(tx: Hash, contract: any, 
        /**
         * Additional data being returned.
         */
        result: TData);
}
/**
 * Common scheme parameters for schemes that are able to create proposals.
 */
export interface StandardSchemeParams {
    /**
     * Hash of the voting machine parameters to use when voting on a proposal.
     */
    voteParametersHash: Hash;
    /**
     * Address of the voting machine to use when voting on a proposal.
     */
    votingMachineAddress: Address;
}
export { DecodedLogEntryEvent, TransactionReceipt } from "web3";
/**
 * The value of the global config setting `gasPriceAdjustment`
 * This function will be invoked to obtain promise of a desired gas price
 * given the current default gas price which will be determined by the x latest blocks
 * median gas price.
 */
export declare type GasPriceAdjustor = (defaultGasPrice: BigNumber) => Promise<BigNumber | string>;
