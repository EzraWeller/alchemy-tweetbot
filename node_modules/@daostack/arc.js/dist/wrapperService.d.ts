import { Address } from "./commonTypes";
import { IContractWrapper, IContractWrapperFactory, IUniversalSchemeWrapper } from "./iContractWrapperBase";
import { AbsoluteVoteWrapper } from "./wrappers/absoluteVote";
import { ContributionRewardWrapper } from "./wrappers/contributionReward";
import { DaoCreatorWrapper } from "./wrappers/daoCreator";
import { DaoTokenWrapper } from "./wrappers/daoToken";
import { GenesisProtocolWrapper } from "./wrappers/genesisProtocol";
import { GlobalConstraintRegistrarWrapper } from "./wrappers/globalConstraintRegistrar";
import { IntVoteInterfaceWrapper } from "./wrappers/intVoteInterface";
import { MintableTokenWrapper } from "./wrappers/mintableToken";
import { RedeemerWrapper } from "./wrappers/redeemer";
import { ReputationWrapper } from "./wrappers/reputation";
import { SchemeRegistrarWrapper } from "./wrappers/schemeRegistrar";
import { StandardTokenWrapper } from "./wrappers/standardToken";
import { TokenCapGCWrapper } from "./wrappers/tokenCapGC";
import { UpgradeSchemeWrapper } from "./wrappers/upgradeScheme";
import { VestingSchemeWrapper } from "./wrappers/vestingScheme";
import { VoteInOrganizationSchemeWrapper } from "./wrappers/voteInOrganizationScheme";
/**
 * An object with property names being a contract key and property value as the
 * corresponding wrapper factory (IContractWrapperFactory<TWrapper).
 */
export interface ArcWrapperFactories {
    AbsoluteVote: IContractWrapperFactory<AbsoluteVoteWrapper>;
    ContributionReward: IContractWrapperFactory<ContributionRewardWrapper>;
    DaoCreator: IContractWrapperFactory<DaoCreatorWrapper>;
    DaoToken: IContractWrapperFactory<DaoTokenWrapper>;
    GenesisProtocol: IContractWrapperFactory<GenesisProtocolWrapper>;
    GlobalConstraintRegistrar: IContractWrapperFactory<GlobalConstraintRegistrarWrapper>;
    IntVoteInterface: IContractWrapperFactory<IntVoteInterfaceWrapper>;
    MintableToken: IContractWrapperFactory<MintableTokenWrapper>;
    Redeemer: IContractWrapperFactory<RedeemerWrapper>;
    Reputation: IContractWrapperFactory<ReputationWrapper>;
    SchemeRegistrar: IContractWrapperFactory<SchemeRegistrarWrapper>;
    StandardToken: IContractWrapperFactory<StandardTokenWrapper>;
    TokenCapGC: IContractWrapperFactory<TokenCapGCWrapper>;
    UpgradeScheme: IContractWrapperFactory<UpgradeSchemeWrapper>;
    VestingScheme: IContractWrapperFactory<VestingSchemeWrapper>;
    VoteInOrganizationScheme: IContractWrapperFactory<VoteInOrganizationSchemeWrapper>;
}
/**
 * An object with property names being a contract key and property value as the
 * corresponding wrapper.  Only deployed wrappers are included here.  Other wrappers
 * may be obtained via their factory.
 */
export interface ArcWrappers {
    AbsoluteVote: AbsoluteVoteWrapper;
    ContributionReward: ContributionRewardWrapper;
    DaoCreator: DaoCreatorWrapper;
    GenesisProtocol: GenesisProtocolWrapper;
    GlobalConstraintRegistrar: GlobalConstraintRegistrarWrapper;
    Redeemer: RedeemerWrapper;
    SchemeRegistrar: SchemeRegistrarWrapper;
    TokenCapGC: TokenCapGCWrapper;
    UpgradeScheme: UpgradeSchemeWrapper;
    VestingScheme: VestingSchemeWrapper;
    VoteInOrganizationScheme: VoteInOrganizationSchemeWrapper;
}
/**
 * Arc.js wrapper factories grouped by type.
 */
export interface ArcWrappersByType {
    /**
     * All wrapped contracts
     */
    allWrappers: Array<IContractWrapper>;
    /**
     * All wrapped non-universal schemes
     */
    nonUniversalSchemes: Array<IContractWrapper>;
    /**
     * All wrapped universal schemes
     */
    universalSchemes: Array<IUniversalSchemeWrapper>;
    /**
     * All wrapped voting machines
     */
    votingMachines: Array<IContractWrapper>;
    /**
     * All wrapped global constraints
     */
    globalConstraints: Array<IContractWrapper>;
    /**
     * Other types of wrappers
     */
    other: Array<IContractWrapper>;
}
/**
 * Service that provides access to Arc.js contract wrapper classes and class factories.
 */
export declare class WrapperService {
    /**
     * Wrappers by name, hydrated with contracts as deployed by the running version of Arc.js.
     */
    static wrappers: ArcWrappers;
    /**
     * Contract wrapper factories grouped by type
     */
    static wrappersByType: ArcWrappersByType;
    /**
     * Wrapper factories by name.  Use these when you want to do `.at()` or `.new()`.  You can also
     * use for `deployed()`, but the wrappers for deployed contracts are directly available from the
     * `wrappers` and `wrappersByType` properties.
     */
    static factories: ArcWrapperFactories;
    /**
     * Map of contract wrappers keyed by address.  For example:
     *
     * `const wrapper = WrapperService.wrappersByAddress.get(anAddress);`
     *
     * Currently only returns the wrappers for contracts that were deployed by the running
     * version of Arc.js.
     */
    static wrappersByAddress: Map<Address, IContractWrapper>;
    /**
     * initialize() must be called before any of the static properties will have values.
     * It is called by ArcInitialize(), which in tur must be invoked by any application using Arc.js.
     *
     * @param options
     */
    static initialize(options?: WrapperServiceInitializeOptions): Promise<void>;
    /**
     * Returns the promise of an Arc.js contract wrapper or undefined if not found.
     *
     * Most useful when you have both contract name and address and wish to most
     * efficiently return the associated wrapper, or undefined when not found.
     *
     * @param contractName - name of an Arc contract, like "SchemeRegistrar"
     * @param address - optional
     */
    static getContractWrapper(contractName: string, address?: string): Promise<IContractWrapper | undefined>;
    /**
     * Confirm the given contract wrapper wraps the same contract as it purports to,
     * and is the one deployed in the running version of Arc.js.
     *
     * This will reject wrappers of different versions of contracts with the same name in Arc.
     * @param contractNameWant
     * @param contractWrapperFound
     */
    static confirmContractType(contractWrapperFound: any): Promise<boolean>;
    private static allWrappersFilter;
    private static noWrappersFilter;
}
export interface WrapperFilter {
    AbsoluteVote?: boolean;
    ContributionReward?: boolean;
    DaoCreator?: boolean;
    GenesisProtocol?: boolean;
    GlobalConstraintRegistrar?: boolean;
    Redeemer?: boolean;
    SchemeRegistrar?: boolean;
    TokenCapGC?: boolean;
    UpgradeScheme?: boolean;
    VestingScheme?: boolean;
    VoteInOrganizationScheme?: boolean;
}
export interface WrapperServiceInitializeOptions {
    /**
     * Option filter to only initialize the contracts whose name is set to true.
     * Any that are omitted or set to false here will appear as `null` in
     * WrapperService.wrappers and WrapperService.wrappersByType,
     * and will not be available in WrapperService.wrappersByAddress.
     * But their factories will still be available in WrapperService.factories.
     */
    filter?: WrapperFilter;
}
/**
 * for quicker access to the contract wrappers
 */
export declare const ContractWrappers: ArcWrappers;
/**
 * for quicker access to the contract wrapper factories
 */
export declare const ContractWrapperFactories: ArcWrapperFactories;
/**
 * for quicker access to the contract wrapper types
 */
export declare const ContractWrappersByType: ArcWrappersByType;
/**
 * for quicker access to the contract wrappers by address
 */
export declare const ContractWrappersByAddress: Map<Address, IContractWrapper>;
